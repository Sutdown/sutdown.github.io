<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Coroutine on Sutdown</title><link>https://sutdown.github.io/categories/coroutine/</link><description>Recent content in Coroutine on Sutdown</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 21 Dec 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://sutdown.github.io/categories/coroutine/index.xml" rel="self" type="application/rss+xml"/><item><title>Coroutinelib项目实现</title><link>https://sutdown.github.io/p/coroutinelib%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0/</link><pubDate>Sat, 21 Dec 2024 00:00:00 +0000</pubDate><guid>https://sutdown.github.io/p/coroutinelib%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0/</guid><description>&lt;img src="https://sutdown.github.io/images/5f69c1c1.jpg" alt="Featured image of post Coroutinelib项目实现" /&gt;&lt;p&gt;个人github链接：&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://github.com/Sutdown/coroutinelib" target="_blank" rel="noopener"
&gt;GitHub - Sutdown/coroutinelib: coroutine lib&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;模块&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;input checked="" disabled="" type="checkbox"&gt; thread&lt;/p&gt;
&lt;p&gt;线程模块，封装了pthread里面的一些常用功能，Thread,Semaphore,Mutex,RWMutex,Spinlock等对象，可以方便开发中对线程日常使用 为什么不适用c++11里面的thread 本框架是使用C++11开发，不使用thread，是因为thread其实也是基于pthread实现的。并且C++11里面没有提供读写互斥量，RWMutex，Spinlock等，在高并发场景，这些对象是经常需要用到的。所以选择了自己封装pthread&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;input checked="" disabled="" type="checkbox"&gt; 协程类&lt;/p&gt;
&lt;p&gt;协程：用户态的线程，相当于线程中的线程，更轻量级。后续配置socket hook，可以把复杂的异步调用，封装成同步操作。降低业务逻辑的编写复杂度。 目前该协程是基于ucontext_t来实现的，后续将支持采用boost.context里面的fcontext_t的方式实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;input checked="" disabled="" type="checkbox"&gt; 协程调度&lt;/p&gt;
&lt;p&gt;协程调度器，管理协程的调度，内部实现为一个线程池，支持协程在多线程中切换，也可以指定协程在固定的线程中执行。是一个N-M的协程调度模型，N个线程，M个协程。重复利用每一个线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;input checked="" disabled="" type="checkbox"&gt; 协程IO&lt;/p&gt;
&lt;p&gt;继承与协程调度器，封装了epoll（Linux），并支持定时器功能（使用epoll实现定时器，精度毫秒级）,支持Socket读写时间的添加，删除，取消功能。支持一次性定时器，循环定时器，条件定时器等功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;input checked="" disabled="" type="checkbox"&gt; 定时器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;input disabled="" type="checkbox"&gt; hook&lt;/p&gt;
&lt;p&gt;hook系统底层和socket相关的API，socket io相关的API，以及sleep系列的API。hook的开启控制是线程粒度的。可以自由选择。通过hook模块，可以使一些不具异步功能的API，展现出异步的性能。如（mysql）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="thread"&gt;&lt;a href="#thread" class="header-anchor"&gt;&lt;/a&gt;thread
&lt;/h2&gt;&lt;p&gt;主要有两个类，&lt;code&gt;Semaphore&lt;/code&gt;和&lt;code&gt;Thread&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="semaphore"&gt;&lt;a href="#semaphore" class="header-anchor"&gt;&lt;/a&gt;Semaphore
&lt;/h4&gt;&lt;p&gt;信号量，实现PV操作，主要用于线程同步&lt;/p&gt;
&lt;h4 id="thread-1"&gt;&lt;a href="#thread-1" class="header-anchor"&gt;&lt;/a&gt;Thread
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;系统自动创建主线程t_thread&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由thread类创建的线程。&lt;/p&gt;
&lt;p&gt;m_thread 通常是线程类内部的成员变量，用来存储底层的线程标识符&lt;/p&gt;
&lt;p&gt;t_thread 可能是外部管理线程生命周期的对象或容器，它可以是线程池、线程列表、智能指针等，帮助你在类外部管理多个线程的创建、执行、销毁等操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="协程类"&gt;&lt;a href="#%e5%8d%8f%e7%a8%8b%e7%b1%bb" class="header-anchor"&gt;&lt;/a&gt;协程类
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;非对称模型&lt;/li&gt;
&lt;li&gt;有栈协程，独立栈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于协程类，其中需要什么。协程首先需要随时切换和恢复，这里采用的是&lt;strong&gt;glibc的ucontext组件&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="ucontext_t"&gt;&lt;a href="#ucontext_t" class="header-anchor"&gt;&lt;/a&gt;ucontext_t
&lt;/h3&gt;&lt;p&gt;这个类中有成员：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 当前上下文结束后下一个激活的上下文对象的指针，只在当前上下文是由makecontext创建时有效
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;ucontext_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;uc_link&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 当前上下文的信号屏蔽掩码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;sigset_t&lt;/span&gt; &lt;span class="n"&gt;uc_sigmask&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 当前上下文使用的栈内存空间，只在当前上下文是由makecontext创建时有效
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;stack_t&lt;/span&gt; &lt;span class="n"&gt;uc_stack&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 平台相关的上下文具体内容，包含寄存器的值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;mcontext_t&lt;/span&gt; &lt;span class="n"&gt;uc_mcontext&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 获取当前上下文
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getcontext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ucontext_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ucp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 恢复ucp指向的上下文
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;setcontext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;ucontext_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ucp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 修改当前上下文指针ucp，将其与func函数绑定
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;makecontext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ucontext_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ucp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)(),&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 将当前上下文保存到oucp中，将执行转到ucp中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;swapcontext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ucontext_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;oucp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;ucontext_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ucp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;对于该协程类，有栈 or 无栈？对称 or 非对称？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于对称和非对称的话，&lt;strong&gt;对称协程更为灵活，非对称协程更为简单易实现&lt;/strong&gt;。协程中一般存在协程调度器和协程两种角色，对称协程中相当于每个协程都要充当调度器的角色，程序设计复杂，程序的控制流也会复杂难以管理。&lt;/p&gt;
&lt;p&gt;常见的&lt;code&gt;js中的async/await&lt;/code&gt;，&lt;code&gt;go中的coroutine&lt;/code&gt;都是非对称协程，是因为非对称协程的切换过程是单项的，更适合事件驱动，任务队列等调度模型；但是c语言中的&lt;code&gt;ucontext&lt;/code&gt;属于对称协程的经典实现，&lt;code&gt;boost.context&lt;/code&gt;为对称协程的现代实现，更适合需要多个协程频繁通信的场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class="link" href="https://mthli.xyz/stackful-stackless/" target="_blank" rel="noopener"
&gt;有栈协程和无栈协程&lt;/a&gt;有栈和无栈的本质区别在于是否可以在任意嵌套函数中被挂起。一般有栈可以被挂起，无栈则不行。有栈比较适用于功能强大，支持嵌套调用和复杂控制流，灵活的操作上下文的需求，比如&lt;code&gt;boost.COntext&lt;/code&gt;；无栈由于存储在内存中，适用于内存占用少，实现简单的场景，比如JavaScript &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; 和 &lt;code&gt;Promise&lt;/code&gt;，Erlang 和 Go的&lt;code&gt;Goroutine&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里我们的协程类，采用的是非对称模型，有栈协程。因此可以推导出所需要的私有成员：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;m_id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;State&lt;/span&gt; &lt;span class="n"&gt;m_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;READY&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;ucontext_t&lt;/span&gt; &lt;span class="n"&gt;m_ctx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;m_stacksze&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 栈大小
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;m_stack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 栈空间
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m_cb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 运行函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;m_runInScheduler&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;对于协程类，我们需要一个主协程和其它的用户协程，以及一个协程调度器。对于主协程则是直接无参构造函数直接创建，（由于只能创建一次，因此私有），有参构造函数创建其它协程。同时需要设置&lt;code&gt;resume,yield&lt;/code&gt;其它函数调度协程的运行。大概这个样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 线程局部变量，当前线程正在运行的协程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;thread_local&lt;/span&gt; &lt;span class="n"&gt;Fiber&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t_fiber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 线程局部变量，当前线程的主协程，切换到这个协程，相当于切换到主线程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;thread_local&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Fiber&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;t_thread_fiber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;thread_local&lt;/span&gt; &lt;span class="n"&gt;Fiber&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t_scheduler_fiber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id="协程调度"&gt;&lt;a href="#%e5%8d%8f%e7%a8%8b%e8%b0%83%e5%ba%a6" class="header-anchor"&gt;&lt;/a&gt;协程调度
&lt;/h2&gt;&lt;p&gt;一个线程只有一个协程，一个协程类中会包含三个协程，分别是主协程（main），调度协程和任务协程。其中任务协程是由协程类自主创建，主协程和调度协程都是静态变量，在多种类中其实只存在一个实体。&lt;/p&gt;
&lt;p&gt;协程调度致力于封装一些操作，因为调度协程本身需要创建协程，协程任务的执行顺序，如何利用多线程或者调度协程池保证效率，在协程任务结束之后也需要停止调度器释放资源。如果建立一个scheduler类封装这些操作，那么为用户开放的仅仅只有&lt;strong&gt;启动线程池，关闭线程池，添加任务&lt;/strong&gt;三种操作了。&lt;/p&gt;
&lt;p&gt;其中main主协程可以选择是否参与调度，如果不参与，那么比如在main开始调度时创建其它协程进行协程调度；如果参与，多线程的情况下和不参与相同。如果是单线程，那么只能等到main结束时开始调度其它协程。&lt;/p&gt;
&lt;p&gt;虽然main是主协程（caller协程），不过main函数所在的线程也能执行任务，在实现相同调度能力的情况下，线程数越少，线程切换的开销也就更小。&lt;/p&gt;
&lt;p&gt;最终过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;main函数主协程运行，创建调度器&lt;/li&gt;
&lt;li&gt;向调度器添加任务，开始协程调度，main让出执行权，调度协程执行任务队列中的任务&lt;/li&gt;
&lt;li&gt;每次执行任务时，调度协程都要让出执行权，再回到调度协程继续下一个任务&lt;/li&gt;
&lt;li&gt;所有任务执行完后，调度协程让出执行权切回main函数主协程结束。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="协程io"&gt;&lt;a href="#%e5%8d%8f%e7%a8%8bio" class="header-anchor"&gt;&lt;/a&gt;协程IO
&lt;/h2&gt;&lt;p&gt;在前面的协程调度模块中，调度器对协程的调度是无条件执行的，在调度器已经启动调度的情况下，任务一旦添加成功，就会排队等待调度器执行。调度器不支持删除调度任务，并且调度器在正常退出之前一定会执行完全部的调度任务，所以在某种程度上可以认为，把一个协程添加到调度器的任务队列，就相当于调用了协程的resume方法。&lt;/p&gt;
&lt;p&gt;IO协程调度支持为描述符注册&lt;strong&gt;可读和可写&lt;/strong&gt;事件的回调函数，当描述符可读或可写时，执行对应的回调函数。&lt;/p&gt;
&lt;p&gt;有的库不仅可以处理socket fd事件，还可以处理定时器事件和信号事件。这些事件库的实现原理基本类似，都是先将套接字设置成非阻塞状态，然后将套接字与回调函数绑定，接下来进入一个基于IO多路复用的事件循环，等待事件发生，然后调用对应的回调函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;改造协程调度器，将epoll和协程调度结合。IO协程调度关注FdCOntext信息，也就是描述符，事件，回调函数三元组。&lt;/li&gt;
&lt;li&gt;基于epoll实现IO事件的&lt;strong&gt;添加，删除，调度，取消&lt;/strong&gt;等功能&lt;/li&gt;
&lt;li&gt;timer会给协程IO外挂一个定时器管理模块，epoll会根据定时器的超时时间确定超时参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;pipe设置的作用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似于进程间通信.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;属于状态传递。比如p[0]和p[1]，p[0]为可读，p[1]为可写。在本过程中，p[0]中存放阻塞的协程，当有协程任务完成时会放入p[1]，p[1]会通知p[0]，从而让调度器run&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 &lt;code&gt;epoll&lt;/code&gt; 中，如果使用 &lt;strong&gt;边缘触发（ET）&lt;/strong&gt; 模式，只有当管道的状态从不可读变为可读时，&lt;code&gt;epoll&lt;/code&gt; 才会通知调度器。这就意味着，调度器需要及时读取管道中的数据，以确保不会错过事件。&lt;/p&gt;
&lt;p&gt;管道变为可读时，会唤醒协程的原因是管道充当了一个信号通知机制。通过向管道的写端写入数据，调度器可以通过读取管道来检测到事件的发生，从而恢复挂起的协程。在协程 I/O 模型中，管道的可读状态就是调度器知道某个事件发生并且可以继续执行协程的信号。这种机制使得协程的调度更加高效，避免了繁重的轮询操作，并且能够通过 I/O 多路复用和事件驱动的方式来处理并发任务。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;协程执行 I/O 操作并挂起：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;一个协程在执行 I/O 操作时，可能会遇到阻塞情况（例如等待网络数据或磁盘读写），于是它会被挂起。挂起的协程会注册相关的文件描述符（如 &lt;code&gt;m_tickleFds[0]&lt;/code&gt;）到 &lt;code&gt;epoll&lt;/code&gt;，让调度器等待这些文件描述符的状态变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="2"&gt;
&lt;li&gt;&lt;strong&gt;信号发送（管道写端）&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;另一个协程或线程会向 &lt;code&gt;m_tickleFds[1]&lt;/code&gt; 写入数据。这通常表示某个事件或任务已经完成，或者需要通知调度器去恢复某个协程的执行。&lt;/li&gt;
&lt;li&gt;当数据写入 &lt;code&gt;m_tickleFds[1]&lt;/code&gt; 时，管道的读端（&lt;code&gt;m_tickleFds[0]&lt;/code&gt;）就变为可读。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="3"&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;epoll&lt;/code&gt; 通知调度器：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;epoll&lt;/code&gt; 会在 &lt;code&gt;m_tickleFds[0]&lt;/code&gt; 变为可读时通知调度器，这时调度器知道管道中有数据，可以读取并继续执行后续操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="4"&gt;
&lt;li&gt;&lt;strong&gt;调度器恢复协程：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;调度器通过 &lt;code&gt;epoll_wait()&lt;/code&gt; 等待管道事件的触发，当管道变为可读时，调度器会恢复挂起的协程。恢复后的协程将继续执行它的任务，直到下一个 I/O 操作发生，或者任务完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="5"&gt;
&lt;li&gt;&lt;strong&gt;读取管道数据：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;当管道可读时，调度器会调用 &lt;code&gt;read(m_tickleFds[0], ...)&lt;/code&gt; 从管道中读取数据。此时，管道中的数据只是一个信号，指示协程应该恢复执行。读取数据的操作不会对协程本身产生影响，但它确保了管道的数据被消费，防止事件丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;epoll and scheduler&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;epoll：当某个文件描述符准备好进行读写操作时，&lt;code&gt;epoll&lt;/code&gt; 会通知应用程序。&lt;/li&gt;
&lt;li&gt;scheduler：管理和调度多个协程的执行&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;协程执行 I/O 操作，发起 &lt;code&gt;read&lt;/code&gt; 或 &lt;code&gt;write&lt;/code&gt; 等阻塞操作。&lt;/li&gt;
&lt;li&gt;协程调度器将该协程挂起，并将文件描述符注册到 &lt;code&gt;epoll&lt;/code&gt; 中，等待 I/O 完成。&lt;/li&gt;
&lt;li&gt;调度器继续调度其他协程或任务（例如，处理其他 I/O 请求）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;epoll&lt;/code&gt; 监听文件描述符的状态，发现某个文件描述符可读或可写时，通知调度器。&lt;/li&gt;
&lt;li&gt;调度器根据 &lt;code&gt;epoll&lt;/code&gt; 返回的事件唤醒对应的协程，恢复执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;idle的触发，自动触发还是人为触发&lt;/p&gt;
&lt;p&gt;&lt;code&gt;idle&lt;/code&gt; 协程的作用是作为一个事件循环，&lt;strong&gt;专门处理 I/O 事件&lt;/strong&gt;和定时器超时事件。它通常在 &lt;strong&gt;没有其他待处理任务时&lt;/strong&gt; 被&lt;strong&gt;调度&lt;/strong&gt;运行。（调度器为空时，处理epoll的IO事件）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;idle&lt;/code&gt; 协程的执行流程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;进入 &lt;code&gt;idle&lt;/code&gt; 协程&lt;/strong&gt;：当&lt;strong&gt;协程调度器&lt;/strong&gt;发现没有任何任务需要执行时，它会选择 &lt;code&gt;idle&lt;/code&gt; 协程。&lt;code&gt;idle&lt;/code&gt; 协程会通过 &lt;code&gt;epoll_wait&lt;/code&gt; 等机制进入阻塞状态，等待 I/O 或定时器事件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件发生时唤醒 &lt;code&gt;idle&lt;/code&gt; 协程&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;I/O 事件&lt;/strong&gt;：当某个文件描述符变得可读或可写，或者出现连接事件时，&lt;code&gt;epoll_wait&lt;/code&gt; 会返回相应的事件。&lt;code&gt;idle&lt;/code&gt; 协程会从阻塞状态中唤醒并处理这些事件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定时器事件&lt;/strong&gt;：如果有定时器超时，&lt;code&gt;idle&lt;/code&gt; 协程会处理定时器回调，并将相应的任务调度到执行队列中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;完成事件处理后重新挂起&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;在处理完所有的事件之后，&lt;code&gt;idle&lt;/code&gt; 协程会检查是否有新的任务需要处理。如果没有，它会调用 &lt;code&gt;yield()&lt;/code&gt; 或其他方式挂起自己，等待下一次事件发生。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="定时器"&gt;&lt;a href="#%e5%ae%9a%e6%97%b6%e5%99%a8" class="header-anchor"&gt;&lt;/a&gt;定时器
&lt;/h2&gt;&lt;p&gt;最小堆定时器&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;创建协程和事件注册&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;协程开始执行某些 I/O 操作时（例如，网络读取、文件读取等），如果该操作是阻塞的，它会通过 &lt;code&gt;epoll&lt;/code&gt; 进行非阻塞的 I/O 多路复用，等待 I/O 完成。&lt;/li&gt;
&lt;li&gt;同时，如果需要设置超时或定时任务，定时器会创建并开始计时。定时器会生成一个文件描述符，可以通过 &lt;code&gt;epoll&lt;/code&gt; 监视。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="2"&gt;
&lt;li&gt;&lt;strong&gt;调度器挂起协程&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;调度器将执行中的协程挂起，并将其状态保存。&lt;/li&gt;
&lt;li&gt;调度器通过 &lt;code&gt;epoll&lt;/code&gt; 将相关的文件描述符（如网络套接字、定时器等）注册到 &lt;code&gt;epoll&lt;/code&gt; 中，以便监听 I/O 事件和定时器事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="3"&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;epoll&lt;/code&gt; 等待事件&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;调度器会调用 &lt;code&gt;epoll_wait()&lt;/code&gt;，等待 I/O 事件或定时器事件的发生。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;epoll_wait()&lt;/code&gt; 是阻塞的，它会一直等待，直到至少一个注册的文件描述符发生事件（如 I/O 准备好或定时器超时）。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="4"&gt;
&lt;li&gt;&lt;strong&gt;事件发生，唤醒协程&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;一旦某个文件描述符发生了事件（如 I/O 完成或定时器到期），&lt;code&gt;epoll&lt;/code&gt; 会通知调度器。&lt;/li&gt;
&lt;li&gt;调度器根据事件类型（如文件描述符是否可读、可写或定时器是否到期）选择唤醒对应的协程，并恢复执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="5"&gt;
&lt;li&gt;&lt;strong&gt;协程继续执行&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;恢复的协程可以继续执行其原本的 I/O 操作，或是进行其他任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="hook"&gt;&lt;a href="#hook" class="header-anchor"&gt;&lt;/a&gt;hook
&lt;/h2&gt;&lt;p&gt;hook是对系统调用API进行一次封装，将其封装成一个与原始的系统调用API同名的接口在应用这个接口时，会先执行封装中的操作，再执行原始的系统调用API。&lt;/p&gt;
&lt;p&gt;本项目中，出于保障协程能够在发生阻塞时随时切换，因此会对IO协程调度中相关的系统调用进行hook，让调度协程尽可能把时间片花在有意义的操作上。 hook的重点在于替换API的底层实现同时完全模拟原本的行为*/&lt;/p&gt;
&lt;p&gt;本项目中，关于hook模块和IO协程调度的整合，一共有三类接口需要hook：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;sleep延时系列接口。对于这些接口，给IO协程调度器注册一个定时事件，定时事件触发之后再执行当前协程即可。 注册完之后yield让出执行权。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;socket IO系系列接口。包括read/write/recv/send/connect/accept&amp;hellip;这类接口的hook需要先判断fd是否为socket fd， 以及用户是否显式的对该fd设置过非阻塞模式，如果都不是，就不需要hook了。如果需要hook，现在IO协程调度器上注册对应读写事件，事件发生后再继续当前协程。当前协程注册完IO之后即可yield让出执行权。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;socket/fcntl/ioctl/close&amp;hellip;这类接口主要用于处理边缘情况， 比如fd上下文，处理超时，显示非阻塞等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;我的钩子函数如何覆盖系统调用的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设以sleep为例，下面可以确保sleep_f可以指向原始的系统调用sleep函数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#define XX(name) name##_f = (name##_fun)dlsym(RTLD_NEXT, #name);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;HOOK_FUN&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;XX&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#undef XX
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id="参考"&gt;&lt;a href="#%e5%8f%82%e8%80%83" class="header-anchor"&gt;&lt;/a&gt;参考
&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a class="link" href="https://github.com/youngyangyang04/coroutine-lib/tree/main" target="_blank" rel="noopener"
&gt;代码随想录 - coroutine-lib - github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://github.com/Tencent/libco" target="_blank" rel="noopener"
&gt;libco - github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://www.zhihu.com/question/50185085/answer/183463734" target="_blank" rel="noopener"
&gt;出于什么样的原因，诞生了「协程」这一概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://lewissbaker.github.io/2017/09/25/coroutine-theory" target="_blank" rel="noopener"
&gt;协程理论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://zhuanlan.zhihu.com/p/172471249" target="_blank" rel="noopener"
&gt;什么是协程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://www.zhihu.com/question/20511233/answer/2743607300" target="_blank" rel="noopener"
&gt;协程的好处&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>协程库项目实现2</title><link>https://sutdown.github.io/p/%E5%8D%8F%E7%A8%8B%E5%BA%93%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B02/</link><pubDate>Wed, 18 Dec 2024 00:00:00 +0000</pubDate><guid>https://sutdown.github.io/p/%E5%8D%8F%E7%A8%8B%E5%BA%93%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B02/</guid><description>&lt;img src="https://sutdown.github.io/images/52a22a0c.jpg" alt="Featured image of post 协程库项目实现2" /&gt;&lt;h2 id="协程库项目实现2---thread协程类"&gt;&lt;a href="#%e5%8d%8f%e7%a8%8b%e5%ba%93%e9%a1%b9%e7%9b%ae%e5%ae%9e%e7%8e%b02---thread%e5%8d%8f%e7%a8%8b%e7%b1%bb" class="header-anchor"&gt;&lt;/a&gt;协程库项目实现2 - thread，协程类
&lt;/h2&gt;&lt;h3 id="thread"&gt;&lt;a href="#thread" class="header-anchor"&gt;&lt;/a&gt;thread
&lt;/h3&gt;&lt;p&gt;主要有两个类，&lt;code&gt;Semaphore&lt;/code&gt;和&lt;code&gt;Thread&lt;/code&gt;&lt;/p&gt;
&lt;h5 id="semaphore"&gt;&lt;a href="#semaphore" class="header-anchor"&gt;&lt;/a&gt;Semaphore
&lt;/h5&gt;&lt;p&gt;信号量，实现PV操作，主要用于线程同步&lt;/p&gt;
&lt;h5 id="thread-1"&gt;&lt;a href="#thread-1" class="header-anchor"&gt;&lt;/a&gt;Thread
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;系统自动创建主线程t_thread&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由thread类创建的线程。&lt;/p&gt;
&lt;p&gt;m_thread 通常是线程类内部的成员变量，用来存储底层的线程标识符&lt;/p&gt;
&lt;p&gt;t_thread 可能是外部管理线程生命周期的对象或容器，它可以是线程池、线程列表、智能指针等，帮助你在类外部管理多个线程的创建、执行、销毁等操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="协程类"&gt;&lt;a href="#%e5%8d%8f%e7%a8%8b%e7%b1%bb" class="header-anchor"&gt;&lt;/a&gt;协程类
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;非对称模型&lt;/li&gt;
&lt;li&gt;有栈协程，独立栈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于协程类，其中需要什么。协程首先需要随时切换和恢复，这里采用的是&lt;strong&gt;glibc的ucontext组件&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id="ucontext_t"&gt;&lt;a href="#ucontext_t" class="header-anchor"&gt;&lt;/a&gt;ucontext_t
&lt;/h4&gt;&lt;p&gt;这个类中有成员：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 当前上下文结束后下一个激活的上下文对象的指针，只在当前上下文是由makecontext创建时有效
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;ucontext_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;uc_link&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 当前上下文的信号屏蔽掩码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;sigset_t&lt;/span&gt; &lt;span class="n"&gt;uc_sigmask&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 当前上下文使用的栈内存空间，只在当前上下文是由makecontext创建时有效
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;stack_t&lt;/span&gt; &lt;span class="n"&gt;uc_stack&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 平台相关的上下文具体内容，包含寄存器的值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;mcontext_t&lt;/span&gt; &lt;span class="n"&gt;uc_mcontext&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 获取当前上下文
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getcontext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ucontext_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ucp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 恢复ucp指向的上下文
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;setcontext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;ucontext_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ucp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 修改当前上下文指针ucp，将其与func函数绑定
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;makecontext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ucontext_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ucp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)(),&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 恢复ucp指向的上下文，同时将当前上下文存储到oucp中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;swapcontext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ucontext_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;oucp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;ucontext_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ucp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;对于该协程类，有栈 or 无栈？对称 or 非对称？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于对称和非对称的话，&lt;strong&gt;对称协程更为灵活，非对称协程更为简单易实现&lt;/strong&gt;。协程中一般存在协程调度器和协程两种角色，对称协程中相当于每个协程都要充当调度器的角色，程序设计复杂，程序的控制流也会复杂难以管理。&lt;/p&gt;
&lt;p&gt;常见的&lt;code&gt;js中的async/await&lt;/code&gt;，&lt;code&gt;go中的coroutine&lt;/code&gt;都是非对称协程，是因为非对称协程的切换过程是单项的，更适合事件驱动，任务队列等调度模型；但是c语言中的&lt;code&gt;ucontext&lt;/code&gt;属于对称协程的经典实现，&lt;code&gt;boost.context&lt;/code&gt;为对称协程的现代实现，更适合需要多个协程频繁通信的场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class="link" href="https://mthli.xyz/stackful-stackless/" target="_blank" rel="noopener"
&gt;有栈协程和无栈协程&lt;/a&gt;有栈和无栈的本质区别在于是否可以在任意嵌套函数中被挂起。一般有栈可以被挂起，无栈则不行。有栈比较适用于功能强大，支持嵌套调用和复杂控制流，灵活的操作上下文的需求，比如&lt;code&gt;boost.COntext&lt;/code&gt;；无栈由于存储在内存中，适用于内存占用少，实现简单的场景，比如JavaScript &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; 和 &lt;code&gt;Promise&lt;/code&gt;，Erlang 和 Go的&lt;code&gt;Goroutine&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;共享栈 or 独立栈？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里我们的协程类，采用的是非对称模型，有栈协程。因此可以推导出所需要的私有成员：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;m_id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;State&lt;/span&gt; &lt;span class="n"&gt;m_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;READY&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;ucontext_t&lt;/span&gt; &lt;span class="n"&gt;m_ctx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;m_stacksze&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 栈大小
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;m_stack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 栈空间
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m_cb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 运行函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;m_runInScheduler&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;由于该类过程大致为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;主协程&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;协程调度器&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;协程&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;协程调度器&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;主协程&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;协程调度器&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;协程&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;协程调度器&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在这里存在两种协程调度模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参与调度器，有调度器统一管理协程的切换&lt;/li&gt;
&lt;li&gt;不参与调度器，直接与主线程切换上下文&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 当前正在运行的协程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;thread_local&lt;/span&gt; &lt;span class="n"&gt;Fiber&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t_fiber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 主协程，管理声明周期
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;thread_local&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Fiber&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;t_thread_fiber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 调度协程，管理指针访问
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;thread_local&lt;/span&gt; &lt;span class="n"&gt;Fiber&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t_scheduler_fiber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;整个流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主协程创建&lt;/strong&gt;：线程启动时创建主协程，保存主线程上下文。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用户协程创建&lt;/strong&gt;：通过分配栈空间和初始化上下文创建用户协程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;协程运行&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;resume&lt;/code&gt; 将协程切换到 &lt;strong&gt;RUNNING&lt;/strong&gt;，执行任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任务完成后，协程状态变为 &lt;strong&gt;TERM&lt;/strong&gt;，调用 &lt;code&gt;yield&lt;/code&gt; 切换回调用方上下文。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;协程管理&lt;/strong&gt;：支持通过调度器统一管理协程或直接与主线程切换。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里目前未能体现主协程和调度线程的差别，具体需要等待下一个部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled="" type="checkbox"&gt; 协程类，写一段话&lt;/li&gt;
&lt;li&gt;&lt;input disabled="" type="checkbox"&gt; debug&lt;/li&gt;
&lt;li&gt;&lt;input disabled="" type="checkbox"&gt; test&lt;/li&gt;
&lt;li&gt;&lt;input disabled="" type="checkbox"&gt; 调度池和线程池比较&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="协程调度"&gt;&lt;a href="#%e5%8d%8f%e7%a8%8b%e8%b0%83%e5%ba%a6" class="header-anchor"&gt;&lt;/a&gt;协程调度
&lt;/h3&gt;&lt;p&gt;一个线程只有一个协程，一个协程类中会包含三个协程，分别是主协程（main），调度协程和任务协程。其中任务协程是由协程类自主创建，主协程和调度协程都是静态变量，在多种类中其实只存在一个实体。&lt;/p&gt;
&lt;p&gt;协程调度致力于封装一些操作，因为调度协程本身需要创建协程，协程任务的执行顺序，如何利用多线程或者调度协程池保证效率，在协程任务结束之后也需要停止调度器释放资源。如果建立一个scheduler类封装这些操作，那么为用户开放的仅仅只有&lt;strong&gt;启动线程池，关闭线程池，添加任务&lt;/strong&gt;三种操作了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;引用：（来源：代码随想录）&lt;/p&gt;
&lt;p&gt;调度器内部维护一个任务队列和一个调度线程池。开始调度后，线程池从任务队列里按顺序取任务执行。调度线程可以包含caller线程。当全部任务都执行完了，线程池停止调度，等新的任务进来。添加新任务后，通知线程池有新的任务进来了，线程池重新开始运行调度。停止调度时，各调度线程退出，调度器停止工作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;main函数主协程运行，创建调度器&lt;/li&gt;
&lt;li&gt;仍然是main函数主协程运行，向调度器添加一些调度任务&lt;/li&gt;
&lt;li&gt;开始协程调度，main函数主协程让出执行权，切换到调度协程，调度协程从任务队列里按顺序执行所有的任务&lt;/li&gt;
&lt;li&gt;每次执行一个任务，调度协程都要让出执行权，再切到该任务的协程里去执行，任务执行结束后，还要再切回调度协程，继续下一个任务的调度&lt;/li&gt;
&lt;li&gt;所有任务都执行完后，调度协程还要让出执行权并切回main函数主协程，以保证程序能顺利结束。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;主协程和调度协程的差异&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;特性&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;主协程&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;调度协程&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;初始化方式&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;在线程启动时自动初始化&lt;/td&gt;
&lt;td&gt;调度器初始化时创建&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;标识&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t_thread_fiber&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t_scheduler_fiber&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;上下文栈空间&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;使用线程自身栈&lt;/td&gt;
&lt;td&gt;使用独立分配的栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;主要功能&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;恢复线程的原始上下文，终止线程&lt;/td&gt;
&lt;td&gt;切换并调度用户协程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;运行逻辑&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;不主动运行任何任务逻辑&lt;/td&gt;
&lt;td&gt;包含协程调度的逻辑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;让出目标&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;让出后通常切换到主线程运行&lt;/td&gt;
&lt;td&gt;让出后切换回调度器逻辑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;用途&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;管理线程范围内的根协程&lt;/td&gt;
&lt;td&gt;管理其他协程，选择运行协程&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么有主协程，调度协程，任务协程三种设置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;协程的基础知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="协程io"&gt;&lt;a href="#%e5%8d%8f%e7%a8%8bio" class="header-anchor"&gt;&lt;/a&gt;协程IO
&lt;/h3&gt;&lt;h3 id="定时器"&gt;&lt;a href="#%e5%ae%9a%e6%97%b6%e5%99%a8" class="header-anchor"&gt;&lt;/a&gt;定时器
&lt;/h3&gt;&lt;h3 id="hook"&gt;&lt;a href="#hook" class="header-anchor"&gt;&lt;/a&gt;hook
&lt;/h3&gt;&lt;p&gt;好的，以下是每个函数的含义，以及各个参数的解释：&lt;/p&gt;
&lt;h4 id="1-sleep-和-usleepnanosleep"&gt;&lt;a href="#1-sleep-%e5%92%8c-usleepnanosleep" class="header-anchor"&gt;&lt;/a&gt;1. &lt;code&gt;sleep&lt;/code&gt; 和 &lt;code&gt;usleep&lt;/code&gt;，&lt;code&gt;nanosleep&lt;/code&gt;
&lt;/h4&gt;&lt;h5 id="11-sleepunsigned-int-seconds"&gt;&lt;a href="#11-sleepunsigned-int-seconds" class="header-anchor"&gt;&lt;/a&gt;1.1 &lt;code&gt;sleep(unsigned int seconds)&lt;/code&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：使当前进程暂停执行指定的秒数。期间进程不执行任何操作，直到时间到期或被信号中断。&lt;/li&gt;
&lt;li&gt;参数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;seconds&lt;/code&gt;：要暂停的时间，单位为秒。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;：返回剩余的睡眠时间（秒）。如果被信号中断，返回的值是剩余的时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="12-usleepuseconds_t-usec"&gt;&lt;a href="#12-usleepuseconds_t-usec" class="header-anchor"&gt;&lt;/a&gt;1.2 &lt;code&gt;usleep(useconds_t usec)&lt;/code&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：使当前进程暂停执行指定的微秒数。&lt;/li&gt;
&lt;li&gt;参数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;usec&lt;/code&gt;：要暂停的时间，单位为微秒。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;：成功时返回0。如果发生错误，返回-1，并设置 &lt;code&gt;errno&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="13-nanosleepconst-struct-timespec-req-struct-timespec-rem"&gt;&lt;a href="#13-nanosleepconst-struct-timespec-req-struct-timespec-rem" class="header-anchor"&gt;&lt;/a&gt;1.3 &lt;code&gt;nanosleep(const struct timespec *req, struct timespec *rem)&lt;/code&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：使当前进程暂停执行指定的时间，精度为纳秒。&lt;/li&gt;
&lt;li&gt;参数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;req&lt;/code&gt;：指定暂停的时间。类型为 &lt;code&gt;struct timespec&lt;/code&gt;，其中 &lt;code&gt;tv_sec&lt;/code&gt; 表示秒数，&lt;code&gt;tv_nsec&lt;/code&gt; 表示纳秒数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rem&lt;/code&gt;：如果系统调用被信号中断，返回未完成的时间。这个参数是输出参数，存放剩余时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;：成功时返回0，如果被信号中断，返回-1，并设置 &lt;code&gt;errno&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="2-socket-函数"&gt;&lt;a href="#2-socket-%e5%87%bd%e6%95%b0" class="header-anchor"&gt;&lt;/a&gt;2. Socket 函数
&lt;/h4&gt;&lt;h5 id="21-socketint-domain-int-type-int-protocol"&gt;&lt;a href="#21-socketint-domain-int-type-int-protocol" class="header-anchor"&gt;&lt;/a&gt;2.1 &lt;code&gt;socket(int domain, int type, int protocol)&lt;/code&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：创建一个新的套接字，用于网络通信。&lt;/li&gt;
&lt;li&gt;参数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;domain&lt;/code&gt;：协议族，指定套接字的协议类型。例如：&lt;code&gt;AF_INET&lt;/code&gt;（IPv4地址族），&lt;code&gt;AF_INET6&lt;/code&gt;（IPv6地址族），&lt;code&gt;AF_UNIX&lt;/code&gt;（Unix本地通信）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt;：套接字类型，指定套接字的通信方式。例如：&lt;code&gt;SOCK_STREAM&lt;/code&gt;（流式套接字，TCP连接），&lt;code&gt;SOCK_DGRAM&lt;/code&gt;（数据报套接字，UDP协议）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;protocol&lt;/code&gt;：协议类型，通常设为0，表示选择与套接字类型相关的默认协议。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;：返回套接字的文件描述符（&lt;code&gt;sockfd&lt;/code&gt;），失败时返回-1，并设置 &lt;code&gt;errno&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="22-connectint-sockfd-const-struct-sockaddr-addr-socklen_t-addrlen"&gt;&lt;a href="#22-connectint-sockfd-const-struct-sockaddr-addr-socklen_t-addrlen" class="header-anchor"&gt;&lt;/a&gt;2.2 &lt;code&gt;connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)&lt;/code&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：连接一个套接字到指定的地址，通常用于客户端发起连接。&lt;/li&gt;
&lt;li&gt;参数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sockfd&lt;/code&gt;：创建的套接字描述符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addr&lt;/code&gt;：指向 &lt;code&gt;struct sockaddr&lt;/code&gt; 的指针，包含目标地址的信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addrlen&lt;/code&gt;：&lt;code&gt;addr&lt;/code&gt; 的长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;：成功时返回0，失败时返回-1，并设置 &lt;code&gt;errno&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="23-acceptint-sockfd-struct-sockaddr-addr-socklen_t-addrlen"&gt;&lt;a href="#23-acceptint-sockfd-struct-sockaddr-addr-socklen_t-addrlen" class="header-anchor"&gt;&lt;/a&gt;2.3 &lt;code&gt;accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)&lt;/code&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：接受一个传入的连接请求，通常由服务器调用。&lt;/li&gt;
&lt;li&gt;参数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sockfd&lt;/code&gt;：监听套接字的文件描述符，通常是通过 &lt;code&gt;socket&lt;/code&gt; 创建并调用 &lt;code&gt;bind&lt;/code&gt; 和 &lt;code&gt;listen&lt;/code&gt; 后的套接字。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addr&lt;/code&gt;：输出参数，返回客户端的地址信息，类型为 &lt;code&gt;struct sockaddr&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addrlen&lt;/code&gt;：输入输出参数，表示 &lt;code&gt;addr&lt;/code&gt; 的大小。调用时传入 &lt;code&gt;socklen_t&lt;/code&gt; 类型的值，返回时会修改为实际填充的字节数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;：成功时返回一个新的套接字文件描述符，表示与客户端的连接；失败时返回-1，并设置 &lt;code&gt;errno&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="3-读操作"&gt;&lt;a href="#3-%e8%af%bb%e6%93%8d%e4%bd%9c" class="header-anchor"&gt;&lt;/a&gt;3. 读操作
&lt;/h4&gt;&lt;h5 id="31-readint-fd-void-buf-size_t-count"&gt;&lt;a href="#31-readint-fd-void-buf-size_t-count" class="header-anchor"&gt;&lt;/a&gt;3.1 &lt;code&gt;read(int fd, void *buf, size_t count)&lt;/code&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：从指定文件描述符 &lt;code&gt;fd&lt;/code&gt; 中读取数据。&lt;/li&gt;
&lt;li&gt;参数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fd&lt;/code&gt;：文件描述符，通常是文件、管道、设备或套接字。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buf&lt;/code&gt;：指向缓冲区的指针，数据将被读取到该缓冲区。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count&lt;/code&gt;：要读取的字节数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;：成功时返回读取的字节数，失败时返回-1，并设置 &lt;code&gt;errno&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="32-readvint-fd-const-struct-iovec-iov-int-iovcnt"&gt;&lt;a href="#32-readvint-fd-const-struct-iovec-iov-int-iovcnt" class="header-anchor"&gt;&lt;/a&gt;3.2 &lt;code&gt;readv(int fd, const struct iovec *iov, int iovcnt)&lt;/code&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：从指定文件描述符读取多个缓冲区的数据（&lt;code&gt;read&lt;/code&gt; 的扩展）。&lt;/li&gt;
&lt;li&gt;参数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fd&lt;/code&gt;：文件描述符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iov&lt;/code&gt;：指向 &lt;code&gt;struct iovec&lt;/code&gt; 数组的指针。&lt;code&gt;struct iovec&lt;/code&gt; 结构包含两个字段：&lt;code&gt;iov_base&lt;/code&gt;（指向数据缓冲区的指针）和 &lt;code&gt;iov_len&lt;/code&gt;（缓冲区的大小）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iovcnt&lt;/code&gt;：&lt;code&gt;iov&lt;/code&gt; 数组中的元素数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;：成功时返回读取的字节数，失败时返回-1，并设置 &lt;code&gt;errno&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="33-recvint-sockfd-void-buf-size_t-len-int-flags"&gt;&lt;a href="#33-recvint-sockfd-void-buf-size_t-len-int-flags" class="header-anchor"&gt;&lt;/a&gt;3.3 &lt;code&gt;recv(int sockfd, void *buf, size_t len, int flags)&lt;/code&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：从套接字接收数据，类似于 &lt;code&gt;read&lt;/code&gt;，但用于网络套接字。&lt;/li&gt;
&lt;li&gt;参数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sockfd&lt;/code&gt;：套接字的文件描述符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buf&lt;/code&gt;：数据将被存储的缓冲区。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;len&lt;/code&gt;：要接收的最大字节数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flags&lt;/code&gt;：接收操作的选项，通常是0，也可以设置为其他值，例如 &lt;code&gt;MSG_PEEK&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;：成功时返回接收的字节数，失败时返回-1，并设置 &lt;code&gt;errno&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="34-recvfromint-sockfd-void-buf-size_t-len-int-flags-struct-sockaddr-src_addr-socklen_t-addrlen"&gt;&lt;a href="#34-recvfromint-sockfd-void-buf-size_t-len-int-flags-struct-sockaddr-src_addr-socklen_t-addrlen" class="header-anchor"&gt;&lt;/a&gt;3.4 &lt;code&gt;recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen)&lt;/code&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：从套接字接收数据，并获取发送者的地址，通常用于 UDP 套接字。&lt;/li&gt;
&lt;li&gt;参数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sockfd&lt;/code&gt;：套接字的文件描述符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buf&lt;/code&gt;：数据将被存储的缓冲区。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;len&lt;/code&gt;：要接收的最大字节数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flags&lt;/code&gt;：接收操作的选项，通常是0。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;src_addr&lt;/code&gt;：输出参数，接收方的地址信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addrlen&lt;/code&gt;：输入输出参数，表示 &lt;code&gt;src_addr&lt;/code&gt; 的大小，调用时传入，返回时更新为实际地址大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;：成功时返回接收的字节数，失败时返回-1，并设置 &lt;code&gt;errno&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="35-recvmsgint-sockfd-struct-msghdr-msg-int-flags"&gt;&lt;a href="#35-recvmsgint-sockfd-struct-msghdr-msg-int-flags" class="header-anchor"&gt;&lt;/a&gt;3.5 &lt;code&gt;recvmsg(int sockfd, struct msghdr *msg, int flags)&lt;/code&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：接收多个消息或者带有复杂头部的消息，通常用于需要复杂协议的套接字（如 ICMP）。&lt;/li&gt;
&lt;li&gt;参数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sockfd&lt;/code&gt;：套接字的文件描述符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;msg&lt;/code&gt;：指向 &lt;code&gt;msghdr&lt;/code&gt; 结构的指针，&lt;code&gt;msghdr&lt;/code&gt; 结构包含了消息的各个部分，如消息数据和头部信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flags&lt;/code&gt;：接收操作的选项。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;：成功时返回接收到的字节数，失败时返回-1，并设置 &lt;code&gt;errno&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="4-写操作"&gt;&lt;a href="#4-%e5%86%99%e6%93%8d%e4%bd%9c" class="header-anchor"&gt;&lt;/a&gt;4. 写操作
&lt;/h4&gt;&lt;h5 id="41-writeint-fd-const-void-buf-size_t-count"&gt;&lt;a href="#41-writeint-fd-const-void-buf-size_t-count" class="header-anchor"&gt;&lt;/a&gt;4.1 &lt;code&gt;write(int fd, const void *buf, size_t count)&lt;/code&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：向文件描述符写入数据。&lt;/li&gt;
&lt;li&gt;参数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fd&lt;/code&gt;：文件描述符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buf&lt;/code&gt;：指向缓冲区的指针，包含要写入的数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count&lt;/code&gt;：要写入的字节数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;：成功时返回写入的字节数，失败时返回-1，并设置 &lt;code&gt;errno&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="42-writevint-fd-const-struct-iovec-iov-int-iovcnt"&gt;&lt;a href="#42-writevint-fd-const-struct-iovec-iov-int-iovcnt" class="header-anchor"&gt;&lt;/a&gt;4.2 &lt;code&gt;writev(int fd, const struct iovec *iov, int iovcnt)&lt;/code&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;含义&lt;/strong&gt;：向文件描述符写入多个缓冲区的数据（&lt;code&gt;write&lt;/code&gt; 的扩展）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;p&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fd&lt;/code&gt;：文件描述符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iov&lt;/code&gt;：指向 &lt;code&gt;struct iovec&lt;/code&gt; 数组的指针。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iovcnt&lt;/code&gt;：&lt;code&gt;iov&lt;/code&gt; 数组中的元素数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：成功时返回写入的字节数，失败时返回-1，并设置 &lt;code&gt;errno&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="43-sendint-sockfd-const-void-buf-size_t-len-int-flags"&gt;&lt;a href="#43-sendint-sockfd-const-void-buf-size_t-len-int-flags" class="header-anchor"&gt;&lt;/a&gt;4.3 &lt;code&gt;send(int sockfd, const void *buf, size_t len, int flags)&lt;/code&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：通过套接字发送数据，通常用于 TCP 连接。&lt;/li&gt;
&lt;li&gt;参数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sockfd&lt;/code&gt;：套接字的文件描述符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buf&lt;/code&gt;：要发送的数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;len&lt;/code&gt;：数据的字节数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flags&lt;/code&gt;：发送操作的选项。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;：成功时返回发送的字节数，失败时返回-1，并设置 &lt;code&gt;errno&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="44-sendtoint-sockfd-const-void-buf-size_t-len-int-flags-const-struct-sockaddr-dest_addr-socklen_t-addrlen"&gt;&lt;a href="#44-sendtoint-sockfd-const-void-buf-size_t-len-int-flags-const-struct-sockaddr-dest_addr-socklen_t-addrlen" class="header-anchor"&gt;&lt;/a&gt;4.4 &lt;code&gt;sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen)&lt;/code&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：通过套接字发送数据，通常用于 UDP 协议。&lt;/li&gt;
&lt;li&gt;参数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sockfd&lt;/code&gt;：套接字的文件描述符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buf&lt;/code&gt;：要发送的数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;len&lt;/code&gt;：数据的字节数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flags&lt;/code&gt;：发送操作的选项。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dest_addr&lt;/code&gt;：目标地址信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addrlen&lt;/code&gt;：目标地址的大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;：成功时返回发送的字节数，失败时返回-1，并设置 &lt;code&gt;errno&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="45-sendmsgint-sockfd-const-struct-msghdr-msg-int-flags"&gt;&lt;a href="#45-sendmsgint-sockfd-const-struct-msghdr-msg-int-flags" class="header-anchor"&gt;&lt;/a&gt;4.5 &lt;code&gt;sendmsg(int sockfd, const struct msghdr *msg, int flags)&lt;/code&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：发送带有复杂消息头的数据，通常用于需要复杂协议的套接字（如 ICMP）。&lt;/li&gt;
&lt;li&gt;参数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sockfd&lt;/code&gt;：套接字的文件描述符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;msg&lt;/code&gt;：指向 &lt;code&gt;msghdr&lt;/code&gt; 结构的指针。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flags&lt;/code&gt;：发送操作的选项。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;：成功时返回发送的字节数，失败时返回-1，并设置 &lt;code&gt;errno&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="5-文件描述符操作"&gt;&lt;a href="#5-%e6%96%87%e4%bb%b6%e6%8f%8f%e8%bf%b0%e7%ac%a6%e6%93%8d%e4%bd%9c" class="header-anchor"&gt;&lt;/a&gt;5. 文件描述符操作
&lt;/h4&gt;&lt;h5 id="51-closeint-fd"&gt;&lt;a href="#51-closeint-fd" class="header-anchor"&gt;&lt;/a&gt;5.1 &lt;code&gt;close(int fd)&lt;/code&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：关闭文件描述符，释放相关资源。&lt;/li&gt;
&lt;li&gt;参数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fd&lt;/code&gt;：文件描述符。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;：成功时返回0，失败时返回-1，并设置 &lt;code&gt;errno&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="6-socket-控制函数"&gt;&lt;a href="#6-socket-%e6%8e%a7%e5%88%b6%e5%87%bd%e6%95%b0" class="header-anchor"&gt;&lt;/a&gt;6. Socket 控制函数
&lt;/h4&gt;&lt;h5 id="61-fcntlint-fd-int-cmd---arg-"&gt;&lt;a href="#61-fcntlint-fd-int-cmd---arg-" class="header-anchor"&gt;&lt;/a&gt;6.1 &lt;code&gt;fcntl(int fd, int cmd, ... /* arg */)&lt;/code&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：操作文件描述符的各种属性，如设置非阻塞模式等。&lt;/li&gt;
&lt;li&gt;参数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fd&lt;/code&gt;：文件描述符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cmd&lt;/code&gt;：命令，指定执行的操作（例如 &lt;code&gt;F_GETFL&lt;/code&gt; 获取文件状态标志，&lt;code&gt;F_SETFL&lt;/code&gt; 设置文件状态标志）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arg&lt;/code&gt;：命令的附加参数，根据命令不同，可能是一个整数或指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;：操作的结果，具体取决于命令和操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="62-ioctlint-fd-unsigned-long-request-"&gt;&lt;a href="#62-ioctlint-fd-unsigned-long-request-" class="header-anchor"&gt;&lt;/a&gt;6.2 &lt;code&gt;ioctl(int fd, unsigned long request, ...)&lt;/code&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：控制设备或套接字的行为。&lt;/li&gt;
&lt;li&gt;参数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fd&lt;/code&gt;：文件描述符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;request&lt;/code&gt;：控制命令，指定要执行的操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;...&lt;/code&gt;：命令的附加参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;：成功时返回0，失败时返回-1，并设置 &lt;code&gt;errno&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="63-getsockoptint-sockfd-int-level-int-optname-void-optval-socklen_t-optlen"&gt;&lt;a href="#63-getsockoptint-sockfd-int-level-int-optname-void-optval-socklen_t-optlen" class="header-anchor"&gt;&lt;/a&gt;6.3 &lt;code&gt;getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen)&lt;/code&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：获取套接字的选项值。&lt;/li&gt;
&lt;li&gt;参数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sockfd&lt;/code&gt;：套接字的文件描述符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;level&lt;/code&gt;：协议层级，指定选项的协议层级（例如 &lt;code&gt;SOL_SOCKET&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;optname&lt;/code&gt;：选项名称，指定要获取的选项。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;optval&lt;/code&gt;：输出参数，接收选项的值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;optlen&lt;/code&gt;：输入输出参数，表示 &lt;code&gt;optval&lt;/code&gt; 的大小，调用时传入，返回时更新为实际大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;：成功时返回0，失败时返回-1，并设置 &lt;code&gt;errno&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="参考"&gt;&lt;a href="#%e5%8f%82%e8%80%83" class="header-anchor"&gt;&lt;/a&gt;参考
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;代码随想录协程库项目精讲&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>协程库项目实现1</title><link>https://sutdown.github.io/p/%E5%8D%8F%E7%A8%8B%E5%BA%93%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B01/</link><pubDate>Tue, 10 Dec 2024 00:00:00 +0000</pubDate><guid>https://sutdown.github.io/p/%E5%8D%8F%E7%A8%8B%E5%BA%93%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B01/</guid><description>&lt;img src="https://sutdown.github.io/images/e20ab07c.jpg" alt="Featured image of post 协程库项目实现1" /&gt;&lt;h2 id="协程库项目实现1"&gt;&lt;a href="#%e5%8d%8f%e7%a8%8b%e5%ba%93%e9%a1%b9%e7%9b%ae%e5%ae%9e%e7%8e%b01" class="header-anchor"&gt;&lt;/a&gt;协程库项目实现1
&lt;/h2&gt;&lt;p&gt;github项目链接：&lt;a class="link" href="https://github.com/Sutdown/coroutinelib" target="_blank" rel="noopener"
&gt;GitHub - Sutdown/coroutinelib: coroutine lib&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="前言碎碎念一下"&gt;&lt;a href="#%e5%89%8d%e8%a8%80%e7%a2%8e%e7%a2%8e%e5%bf%b5%e4%b8%80%e4%b8%8b" class="header-anchor"&gt;&lt;/a&gt;前言（碎碎念一下）
&lt;/h3&gt;&lt;p&gt;之前学着写了下&lt;code&gt;lsm tree&lt;/code&gt;，学到的东西远比想象的要多，从九月份开始到现在，大概两三个月时间，和六级备考，一些课程期末作业并行，日均大概在10+h。两个月前写了个想法自嘲是虚假的科班选手，也没做，起码大学的前两年实在没走在学习&lt;code&gt;cpp&lt;/code&gt;的正确道路上，不过感谢学校了，以前似懂非懂用的工具写的代码如今都慢慢理解了曾经是在做什么。这几个月从&lt;code&gt;c++&lt;/code&gt;新特性，到&lt;code&gt;linux&lt;/code&gt;内核，到看各种源码，到自己上手从0开始写着项目，深刻感觉此时彷佛才真正是开始入门。&lt;/p&gt;
&lt;p&gt;“道阻且长，行则降至。”&lt;/p&gt;
&lt;p&gt;11月马上也要结束了，害，时间过的真快啊，之前还计划着写这个之前看看&lt;a class="link" href="https://github.com/Tencent/libco" target="_blank" rel="noopener"
&gt;&lt;code&gt;libco&lt;/code&gt;&lt;/a&gt;，这个想法往后推迟吧。不过写协程库之前还是得大致对协程有个简单了解的，这篇文章&lt;strong&gt;着重于协程介绍&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="正文篇1-个人理解"&gt;&lt;a href="#%e6%ad%a3%e6%96%87%e7%af%871-%e4%b8%aa%e4%ba%ba%e7%90%86%e8%a7%a3" class="header-anchor"&gt;&lt;/a&gt;正文篇1 个人理解
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;进程，线程，协程之间的关系，出现的原因，历史渊源等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进程是计算机中最先出现的概念，也就是当程序执行一个可执行文件时，cpu从前往后执行这个程序的文件，这个过程也就被成为&lt;strong&gt;进程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最刚开始我们默认单核cpu只能执行一个进程，但当进程被中断时，cpu会阻塞进程等待&lt;strong&gt;中断&lt;/strong&gt;返回，中断一般由&lt;strong&gt;内核中的中断处理程序响应&lt;/strong&gt;，一般中断会尽可能的短且块，这样尽量减少正常进程运行调度的时间。关于中断，中断其实是分为&lt;strong&gt;软中断和硬中断&lt;/strong&gt;的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬中断是由CPU给物理引脚施加电压变化实现的。一般位于linux内核实现的上半部分，快速处理一些简单的部分，之后发出软中断。&lt;/li&gt;
&lt;li&gt;软中断是通过给内存中的一个变量赋予二进制值以标记有软中断的发生。软中断主要由ksoftirqd(kernel software interrupt queue daemon内核软中断队列守护)线程处理会用&lt;strong&gt;ringbuffer&lt;/strong&gt;收包然后交给各个协议层处理，对于TCP则是socket队列。
&lt;ul&gt;
&lt;li&gt;软中断一般是由中断处理程序和软中断线程的情况下发生，很类似于单一生产者消费者模拟，和环形缓冲区的经典应用场景相匹配。软中断的过程为，硬件中断触发时，将接收的数据包放入环形缓冲区，协议栈读取环形缓冲区进行进一步处理。其优点在于连续内存的使用使得能够快速读取，固定容量无需动态分配内存，可以使用无锁实现高效并发（生产者和消费者线程的指针独立，不存在竞争）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;回到进程，为了高效利用中断时的时间，因此产生了&lt;strong&gt;并发&lt;/strong&gt;。并发时，一个进程切换到另一个线程运行，这个成为&lt;strong&gt;进程的上下文切换&lt;/strong&gt;，进程的上下文切换其实不仅包含了虚拟内存，栈，全局变量等用户空间的资源，还包含了内核堆栈，寄存器等内核空间的资源。&lt;/p&gt;
&lt;p&gt;由于进程之间无论是切换，还是数据其实都是单独的，如果想要并发运行或者共享数据都是极为复杂的，因此提出了&lt;strong&gt;线程&lt;/strong&gt;的概念，线程之间可以&lt;strong&gt;并行运行，也可以共享相同的地址空间&lt;/strong&gt;，同时将线程设置为进程当中的一条执行流程，也就是进程的下一个级别。&lt;/p&gt;
&lt;p&gt;因此我们常说，&lt;strong&gt;进程是资源分配的单位，线程是cpu调度的单位&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于进程和线程，其实还有很多可以讨论的问题，比如进程间的通信方式；多线程需要共享数据，那么如何避免冲突；进程最多可以创建多少个线程；线程崩溃进程也会崩溃吗；死锁，悲观锁，乐观锁，共享锁，排他锁，这么多锁的说法到底是怎么一回事。这些如果讲起来就有点偏离本篇协程的主题了，因此估计会再写一篇文章吧，留个悬念。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;协程的本质是什么，为了解决什么事情&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面2中有句话说的很合适，&lt;strong&gt;协程&lt;/strong&gt; 的发明是为了解决线程的 &lt;strong&gt;Concurrency（并发）&lt;/strong&gt;，&lt;strong&gt;线程&lt;/strong&gt; 的发明解决进程的 &lt;strong&gt;Parallelism（并行）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;协程其实有点像线程下的级别，线程在解决某个任务时，仍然会有等待的时间，这段等待可能是线程加载时的IO操作，基本不消耗cpu资源，如果这段时间用于&lt;strong&gt;线程切换&lt;/strong&gt;的话，可以，但是存在一定的开销。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;协程的创建&lt;/strong&gt;并非操作系统层面，不涉及内核调度，一般直接用编程语言实现，属于用户态。这个过程&lt;strong&gt;类似于线程内实现的并发&lt;/strong&gt;，协程作为一种特殊的subroutine，可以在执行一半时暂停，这样在遇到IO之类不消耗cpu的操作时，可以将其挂起，继续计算其它任务，充分利用cpu资源。&lt;/p&gt;
&lt;p&gt;sylar的协程实现使用了非对称模型，且保证子协程不能再创建新的协程，即协程不能嵌套调用，子协程只能与线程主协程进行切换，这种模型简单，非常容易理解。&lt;/p&gt;
&lt;h3 id="正文篇2-摘录"&gt;&lt;a href="#%e6%ad%a3%e6%96%87%e7%af%872-%e6%91%98%e5%bd%95" class="header-anchor"&gt;&lt;/a&gt;正文篇2 摘录
&lt;/h3&gt;&lt;p&gt;（来源见参考链接）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;协程&lt;/strong&gt; 的发明主要是为了解决 &lt;strong&gt;Concurrency（并发）&lt;/strong&gt; 问题，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt; 的发明主要解决的 &lt;strong&gt;Parallelism（并行）&lt;/strong&gt; 问题。&lt;/p&gt;
&lt;h4 id="协程简单介绍"&gt;&lt;a href="#%e5%8d%8f%e7%a8%8b%e7%ae%80%e5%8d%95%e4%bb%8b%e7%bb%8d" class="header-anchor"&gt;&lt;/a&gt;协程简单介绍
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;“其实不应该把协程和多线程做类比，协程更多的是取代异步状态机的数据结构，如果明确这点，就能够清晰使用场景了。” —— from libco 的实现者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[什么是协程](https:// zhuanlan.zhihu.com/p/172471249)&lt;/p&gt;
&lt;p&gt;协程是一类程序组件，它是对子过程概念的泛化，并且是属于非抢占的多任务处理。&lt;/p&gt;
&lt;p&gt;它的两个关键概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;泛化的子过程&lt;/li&gt;
&lt;li&gt;非抢占的多任务处理&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;每个协程在创建时都会指定一个入口函数，这点可以类比线程。协程的本质就是函数和函数运行状态的组合 。协程和函数的不同之处是，函数一旦被调用，只能从头开始执行，直到函数执行结束退出，而协程则可以执行到一半就退出（称为yield），但此时协程并未真正结束，只是暂时让出CPU执行权，在后面适当的时机协程可以重新恢复运行（称为resume），在这段时间里其他的协程可以获得CPU并运行，所以协程被描述称为“&lt;strong&gt;轻量级线程&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;协程能够半路yield、再重新resume的关键是协程存储了函数在yield时间点的执行状态，这个状态称为协程上下文。协程上下文包含了函数在当前执行状态下的全部CPU寄存器的值，这些寄存器值记录了函数栈帧、代码的执行位置等信息，如果将这些寄存器的值重新设置给CPU，就相当于重新恢复了函数的运行。&lt;/p&gt;
&lt;p&gt;单线程环境下，协程的yield和resume一定是同步进行的，一个协程的yield，必然对应另一个协程的resume，因为线程不可能没有执行主体。并且，协程的yield和resume是完全由应用程序来控制的。与线程不同，线程创建之后，线程的运行和调度也是由操作系统自动完成的，但协程创建后，协程的运行和调度都要由应用程序来完成，就和调用函数一样，所以协程也被称为“&lt;strong&gt;用户态线程&lt;/strong&gt;”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="协程理论"&gt;&lt;a href="#%e5%8d%8f%e7%a8%8b%e7%90%86%e8%ae%ba" class="header-anchor"&gt;&lt;/a&gt;协程理论
&lt;/h4&gt;&lt;h5 id="协程就是函数"&gt;&lt;a href="#%e5%8d%8f%e7%a8%8b%e5%b0%b1%e6%98%af%e5%87%bd%e6%95%b0" class="header-anchor"&gt;&lt;/a&gt;协程就是函数
&lt;/h5&gt;&lt;p&gt;协程是函数的一种泛化，允许暂停函数并稍后恢复。&lt;/p&gt;
&lt;h5 id="对称协程和非对称协程"&gt;&lt;a href="#%e5%af%b9%e7%a7%b0%e5%8d%8f%e7%a8%8b%e5%92%8c%e9%9d%9e%e5%af%b9%e7%a7%b0%e5%8d%8f%e7%a8%8b" class="header-anchor"&gt;&lt;/a&gt;对称协程和非对称协程
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;对称协程，协程可以不受限制地将控制权交给任何其他协程。&lt;/li&gt;
&lt;li&gt;非对称协程，是指协程之间存在类似堆栈的调用方-被调用方关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对称协程更灵活，非对称协程实现更简单。&lt;/p&gt;
&lt;h5 id="有栈协程和无栈协程"&gt;&lt;a href="#%e6%9c%89%e6%a0%88%e5%8d%8f%e7%a8%8b%e5%92%8c%e6%97%a0%e6%a0%88%e5%8d%8f%e7%a8%8b" class="header-anchor"&gt;&lt;/a&gt;有栈协程和无栈协程
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;有栈协程：用独立的执行栈来保存协程的上下文信息。有栈协程的核心是io的异步化，要hook常用io.&lt;/li&gt;
&lt;li&gt;无栈协程：它不需要独立的执行栈来保存协程的上下文信息，协程的上下文都放到公共内存中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id="有栈协程"&gt;&lt;a href="#%e6%9c%89%e6%a0%88%e5%8d%8f%e7%a8%8b" class="header-anchor"&gt;&lt;/a&gt;有栈协程
&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;独立栈：独立栈，也就是每个协程的栈空间都是独立的，固定大小&lt;/li&gt;
&lt;li&gt;共享栈：共享质就是所有的协程在运行的时候都使用同一个栈空间，每次协程切换时要把自身用的共享栈空间拷⻉。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;独立栈和共享栈&lt;/p&gt;
&lt;h2 id="参考资料"&gt;&lt;a href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99" class="header-anchor"&gt;&lt;/a&gt;参考资料
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a class="link" href="https://github.com/youngyangyang04/coroutine-lib/tree/main" target="_blank" rel="noopener"
&gt;代码随想录 - coroutine-lib - github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://github.com/Tencent/libco" target="_blank" rel="noopener"
&gt;libco - github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://www.zhihu.com/question/50185085/answer/183463734" target="_blank" rel="noopener"
&gt;出于什么样的原因，诞生了「协程」这一概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://lewissbaker.github.io/2017/09/25/coroutine-theory" target="_blank" rel="noopener"
&gt;协程理论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://zhuanlan.zhihu.com/p/172471249" target="_blank" rel="noopener"
&gt;什么是协程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://www.zhihu.com/question/20511233/answer/2743607300" target="_blank" rel="noopener"
&gt;协程的好处&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>协程详解</title><link>https://sutdown.github.io/p/%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 02 Dec 2024 00:00:00 +0000</pubDate><guid>https://sutdown.github.io/p/%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/</guid><description>&lt;img src="https://sutdown.github.io/images/c85bd259.jpg" alt="Featured image of post 协程详解" /&gt;&lt;h2 id="协程详解"&gt;&lt;a href="#%e5%8d%8f%e7%a8%8b%e8%af%a6%e8%a7%a3" class="header-anchor"&gt;&lt;/a&gt;协程详解
&lt;/h2&gt;&lt;h3 id="前言"&gt;&lt;a href="#%e5%89%8d%e8%a8%80" class="header-anchor"&gt;&lt;/a&gt;前言
&lt;/h3&gt;&lt;p&gt;最近在学协程库，因为计划是12月底之前，时间有限想着直接从代码起步，果然这样子还是不好的，这几天很多东西处于一种似懂非懂的状态，很难受。所以决定写篇文章重新捋一下，之前也写过一点点，但是太浅了。&lt;/p&gt;
&lt;p&gt;主要参考&lt;a class="link" href="https://www.zhihu.com/question/625089836/answer/3243736805" target="_blank" rel="noopener"
&gt;有没有C++大佬把C++20的协程讲解下？ - 知乎&lt;/a&gt;这个问题中&lt;a class="link" href="https://www.zhihu.com/people/frmf" target="_blank" rel="noopener"
&gt;南山烟雨珠江潮 - 知乎&lt;/a&gt;的回答，以及代码随想录的&lt;a class="link" href="https://github.com/youngyangyang04/coroutine-lib/tree/main" target="_blank" rel="noopener"
&gt;协程库源码&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id="正文"&gt;&lt;a href="#%e6%ad%a3%e6%96%87" class="header-anchor"&gt;&lt;/a&gt;正文
&lt;/h3&gt;&lt;h4 id="进程线程协程"&gt;&lt;a href="#%e8%bf%9b%e7%a8%8b%e7%ba%bf%e7%a8%8b%e5%8d%8f%e7%a8%8b" class="header-anchor"&gt;&lt;/a&gt;进程线程协程
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;进程，线程，协程之间的关系，出现的原因，历史渊源等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;理解进程和线程从基本概念着手，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;可以简单认为是由程序代码，相关数据还有进程控制块组成的。操作系统基本职责是控制进程的执行，这包括交替执行的方式以及为进程分配资源。&lt;/p&gt;
&lt;p&gt;倘若我们要执行一个任务，如果全由进程从头至尾执行那必然效率一般，会思考如果将任务分成不同部分，交由不同的进程并行执行能不能提高效率？进程间的地址空间一般来说都是独立不能互相访问的，如果想要通信必须经过内核，那很明显执行一个任务多次进入内核是得不偿失的。因此出现了&lt;strong&gt;线程&lt;/strong&gt;，线程是由线程id，程序计数器，寄存器集合和栈组成，一个进程可以有多个线程，线程之间是共享地址空间的，同时多核cpu能够让多线程并行执行，成功达到了提高性能的作用。所以也可以理解成，线程解决了进程的并行问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于进程和线程，其实还有很多可以讨论的问题，比如进程间的通信方式；多线程需要共享数据，那么如何避免冲突；进程最多可以创建多少个线程；线程崩溃进程也会崩溃吗；死锁，悲观锁，乐观锁，共享锁，排他锁，这么多锁的说法到底是怎么一回事。这些如果讲起来就有点偏离本篇协程的主题了，因此估计会再写一篇文章吧，留个悬念。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="协程的使用"&gt;&lt;a href="#%e5%8d%8f%e7%a8%8b%e7%9a%84%e4%bd%bf%e7%94%a8" class="header-anchor"&gt;&lt;/a&gt;协程的使用
&lt;/h4&gt;&lt;p&gt;&lt;a class="link" href="https://www.cnblogs.com/blizzard8204/p/17563217.html" target="_blank" rel="noopener"
&gt;https://www.cnblogs.com/blizzard8204/p/17563217.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;语言：C++20 C++20的协程是一个无栈，非对称的协程。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;span class="lnt"&gt;22
&lt;/span&gt;&lt;span class="lnt"&gt;23
&lt;/span&gt;&lt;span class="lnt"&gt;24
&lt;/span&gt;&lt;span class="lnt"&gt;25
&lt;/span&gt;&lt;span class="lnt"&gt;26
&lt;/span&gt;&lt;span class="lnt"&gt;27
&lt;/span&gt;&lt;span class="lnt"&gt;28
&lt;/span&gt;&lt;span class="lnt"&gt;29
&lt;/span&gt;&lt;span class="lnt"&gt;30
&lt;/span&gt;&lt;span class="lnt"&gt;31
&lt;/span&gt;&lt;span class="lnt"&gt;32
&lt;/span&gt;&lt;span class="lnt"&gt;33
&lt;/span&gt;&lt;span class="lnt"&gt;34
&lt;/span&gt;&lt;span class="lnt"&gt;35
&lt;/span&gt;&lt;span class="lnt"&gt;36
&lt;/span&gt;&lt;span class="lnt"&gt;37
&lt;/span&gt;&lt;span class="lnt"&gt;38
&lt;/span&gt;&lt;span class="lnt"&gt;39
&lt;/span&gt;&lt;span class="lnt"&gt;40
&lt;/span&gt;&lt;span class="lnt"&gt;41
&lt;/span&gt;&lt;span class="lnt"&gt;42
&lt;/span&gt;&lt;span class="lnt"&gt;43
&lt;/span&gt;&lt;span class="lnt"&gt;44
&lt;/span&gt;&lt;span class="lnt"&gt;45
&lt;/span&gt;&lt;span class="lnt"&gt;46
&lt;/span&gt;&lt;span class="lnt"&gt;47
&lt;/span&gt;&lt;span class="lnt"&gt;48
&lt;/span&gt;&lt;span class="lnt"&gt;49
&lt;/span&gt;&lt;span class="lnt"&gt;50
&lt;/span&gt;&lt;span class="lnt"&gt;51
&lt;/span&gt;&lt;span class="lnt"&gt;52
&lt;/span&gt;&lt;span class="lnt"&gt;53
&lt;/span&gt;&lt;span class="lnt"&gt;54
&lt;/span&gt;&lt;span class="lnt"&gt;55
&lt;/span&gt;&lt;span class="lnt"&gt;56
&lt;/span&gt;&lt;span class="lnt"&gt;57
&lt;/span&gt;&lt;span class="lnt"&gt;58
&lt;/span&gt;&lt;span class="lnt"&gt;59
&lt;/span&gt;&lt;span class="lnt"&gt;60
&lt;/span&gt;&lt;span class="lnt"&gt;61
&lt;/span&gt;&lt;span class="lnt"&gt;62
&lt;/span&gt;&lt;span class="lnt"&gt;63
&lt;/span&gt;&lt;span class="lnt"&gt;64
&lt;/span&gt;&lt;span class="lnt"&gt;65
&lt;/span&gt;&lt;span class="lnt"&gt;66
&lt;/span&gt;&lt;span class="lnt"&gt;67
&lt;/span&gt;&lt;span class="lnt"&gt;68
&lt;/span&gt;&lt;span class="lnt"&gt;69
&lt;/span&gt;&lt;span class="lnt"&gt;70
&lt;/span&gt;&lt;span class="lnt"&gt;71
&lt;/span&gt;&lt;span class="lnt"&gt;72
&lt;/span&gt;&lt;span class="lnt"&gt;73
&lt;/span&gt;&lt;span class="lnt"&gt;74
&lt;/span&gt;&lt;span class="lnt"&gt;75
&lt;/span&gt;&lt;span class="lnt"&gt;76
&lt;/span&gt;&lt;span class="lnt"&gt;77
&lt;/span&gt;&lt;span class="lnt"&gt;78
&lt;/span&gt;&lt;span class="lnt"&gt;79
&lt;/span&gt;&lt;span class="lnt"&gt;80
&lt;/span&gt;&lt;span class="lnt"&gt;81
&lt;/span&gt;&lt;span class="lnt"&gt;82
&lt;/span&gt;&lt;span class="lnt"&gt;83
&lt;/span&gt;&lt;span class="lnt"&gt;84
&lt;/span&gt;&lt;span class="lnt"&gt;85
&lt;/span&gt;&lt;span class="lnt"&gt;86
&lt;/span&gt;&lt;span class="lnt"&gt;87
&lt;/span&gt;&lt;span class="lnt"&gt;88
&lt;/span&gt;&lt;span class="lnt"&gt;89
&lt;/span&gt;&lt;span class="lnt"&gt;90
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;coroutine&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;optional&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt;* promise_type 定义协程的行为，管理协程生命周期中的各种状态。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt;* Generator 提供协程控制器和迭代器接口，方便协程的使用。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt;* sequence 是一个协程函数，用来生成一个值序列。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 协程的返回类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;Generator&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;promise_type&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;optional&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;current_value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="cm"&gt;/* C++编译器通过函数返回值识别协程函数。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; * 返回类型result中有一个子类型承诺对象（promise），
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; * 通过std::coroutine_handle&amp;lt;promise_type&amp;gt;::from_promise()
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; * 可以得到协程句柄（coroutine handle）。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 生成协程函数的返回对象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Generator&lt;/span&gt; &lt;span class="nf"&gt;get_return_object&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Generator&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;coroutine_handle&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;promise_type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;from_promise&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;suspend_always&lt;/span&gt; &lt;span class="n"&gt;initial_suspend&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;suspend_always&lt;/span&gt; &lt;span class="n"&gt;final_suspend&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;noexcept&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;suspend_always&lt;/span&gt; &lt;span class="n"&gt;yield_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current_value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;return_void&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;unhandled_exception&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 未处理异常时退出程序
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 协程句柄
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;coroutine_handle&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;promise_type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;explicit&lt;/span&gt; &lt;span class="nf"&gt;Generator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;coroutine_handle&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;promise_type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Generator&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;destroy&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;Iterator&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;coroutine_handle&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;promise_type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resume&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;promise&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;current_value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;default_sentinel_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;done&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt; &lt;span class="nf"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resume&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;default_sentinel_t&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 协程函数：生成一个从 1 到 n 的序列
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Generator&lt;/span&gt; &lt;span class="nf"&gt;sequence&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;co_yield&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 协程暂停并返回值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;value&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;sequence&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id="协程学习"&gt;&lt;a href="#%e5%8d%8f%e7%a8%8b%e5%ad%a6%e4%b9%a0" class="header-anchor"&gt;&lt;/a&gt;协程学习
&lt;/h4&gt;&lt;p&gt;&lt;a class="link" href="https://lewissbaker.github.io/2017/09/25/coroutine-theory" target="_blank" rel="noopener"
&gt;https://lewissbaker.github.io/2017/09/25/coroutine-theory&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;协程是函数的泛化。&lt;/p&gt;
&lt;p&gt;对于函数而言，存在两个操作：call和return。&lt;/p&gt;
&lt;p&gt;发生call时，call创建一个激活框架，暂停调用函数的执行，同时将执行转移到调用函数的开始处；return时将返回值传递给调用者，恢复原本调用者的状态，销毁激活框架。这里的激活框架可以视为保存函数特定调用的当前状态的内存块，同时这套激活框架也被成为‘堆栈’。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;协程中有三个&lt;strong&gt;新的语言关键字&lt;/strong&gt;：&lt;code&gt;co_await&lt;/code&gt;、&lt;code&gt;co_yield&lt;/code&gt;和&lt;code&gt;co_return&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命名空间中的几种新类型&lt;code&gt;std::experimental&lt;/code&gt;&amp;quot;&amp;quot;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;coroutine_handle&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;coroutine_traits&amp;lt;Ts...&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;suspend_always&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;suspend_never&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;库编写者可以使用该机制与协程交互并定制其行为。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一种语言工具，使编写异步代码变得更加容易！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当前的协程并没有定义协程的语义。它没有定义如何生成返回给调用者的值。它没有定义如何处理传递给语句的返回值&lt;code&gt;co_return&lt;/code&gt;，或者如何处理从协程传播出去的异常。它没有定义应该在哪个线程上恢复协程。相反，它指定了一种通用机制，让库代码通过实现符合特定接口的类型来定制协程的行为。&lt;/p&gt;
&lt;p&gt;比如可以定义一个异步生成单个值的协程，或者一个延迟生成一系列值的协程，或者一个通过遇到值&lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt;时提前退出简化使用值的协程。&lt;/p&gt;
&lt;p&gt;协程TS定义了两种接口：&lt;code&gt;Promise&lt;/code&gt;接口和&lt;code&gt;Awaitable&lt;/code&gt;接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Promise&lt;/strong&gt;接口指定了&lt;strong&gt;自定义协程本身行为的方法&lt;/strong&gt;。库编写者能够自定义调用协程时发生的情况、协程返回时发生的情况（无论是通过正常方式还是通过未处理的异常），以及自定义协程中任何&lt;code&gt;co_await&lt;/code&gt;或表达式的行为。&lt;code&gt;co_yield&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Awaitable&lt;/strong&gt;接口指定了&lt;strong&gt;控制表达式语义的方法&lt;/strong&gt;&lt;code&gt;co_await&lt;/code&gt; 。当传入一个值时&lt;code&gt;co_await&lt;/code&gt;，代码将被转换为对 awaitable 对象上的一系列方法的调用，这些方法允许它指定：是否暂停当前协程、在暂停后执行某些逻辑以安排协程稍后恢复、以及在协程恢复后执行某些逻辑以产生表达式的结果&lt;code&gt;co_await&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接口清单：&lt;/p&gt;
&lt;h4 id="awaitable"&gt;&lt;a href="#awaitable" class="header-anchor"&gt;&lt;/a&gt;Awaitable
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;awaiter type需要实现如下名字的函数:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;await_ready&lt;/li&gt;
&lt;li&gt;await_suspend&lt;/li&gt;
&lt;li&gt;await_resume&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;awaitable type需要实现如下的操作符重载:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;operator co_await()&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="promise"&gt;&lt;a href="#promise" class="header-anchor"&gt;&lt;/a&gt;Promise
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;promise type需要实现如下名字的函数：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;get_return_object&lt;/li&gt;
&lt;li&gt;initial_suspend&lt;/li&gt;
&lt;li&gt;final_suspend&lt;/li&gt;
&lt;li&gt;unhandled_exception&lt;/li&gt;
&lt;li&gt;return_void&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;promise type可选实现如下名字的函数：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;return_value&lt;/li&gt;
&lt;li&gt;operater new&lt;/li&gt;
&lt;li&gt;operater delete&lt;/li&gt;
&lt;li&gt;get_return_object_on_allocation_failure&lt;/li&gt;
&lt;li&gt;yield_value（co_yield）&lt;/li&gt;
&lt;li&gt;await_transform&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a class="link" href="https://yearn.xyz/posts/techs/%E5%8D%8F%E7%A8%8B/" target="_blank" rel="noopener"
&gt;https://yearn.xyz/posts/techs/%E5%8D%8F%E7%A8%8B/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://itnext.io/c-20-coroutines-complete-guide-7c3fc08db89d" target="_blank" rel="noopener"
&gt;https://itnext.io/c-20-coroutines-complete-guide-7c3fc08db89d&lt;/a&gt;&lt;/p&gt;</description></item></channel></rss>