<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Agent on Sutdown</title><link>https://sutdown.github.io/categories/agent/</link><description>Recent content in Agent on Sutdown</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 01 Dec 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://sutdown.github.io/categories/agent/index.xml" rel="self" type="application/rss+xml"/><item><title>Code Agent</title><link>https://sutdown.github.io/p/code-agent/</link><pubDate>Mon, 01 Dec 2025 00:00:00 +0000</pubDate><guid>https://sutdown.github.io/p/code-agent/</guid><description>&lt;img src="https://sutdown.github.io/images/92dbc608.jpg" alt="Featured image of post Code Agent" /&gt;&lt;p&gt;项目链接：https://github.com/Sutdown/sutdown.github.io.git&lt;/p&gt;
&lt;p&gt;基本分为：client，tools，memory，prompt，mcp，react agent四个部分，最终进行整合。&lt;/p&gt;
&lt;p&gt;agent有三种基本架构：ReAct，plan and solve，reflection三种模式。&lt;/p&gt;
&lt;p&gt;当前采用的是ReaAct架构，即边思考边行动。首先对于给出的问题利用planner进行分析规划成3-8个具体的步骤（每个步骤中包含具体的推理和行动），在每个步骤中利用现有的tools或者mcp进行执行，同时会memory上一个步骤中的结果，为了节省token，也会对整体内容进行compressor。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ReAct (Reasoning and Acting)：&lt;/strong&gt; 一种将“思考”和“行动”紧密结合的范式，让智能体边想边做，动态调整。&lt;/p&gt;
&lt;p&gt;核心在于循环 Thought-Action-Observation 这整个过程，在思考当前情况的时，反思上一步结果指定下一步计划，形成一个不断增长的上下文。最终能够达到：&lt;strong&gt;推理让行动更具有目的性，行动为推理提供实时依据，观察则用于不断优化每次的推理&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Plan-and-Solve：&lt;/strong&gt; 一种“三思而后行”的范式，智能体首先生成一个完整的行动计划，然后严格执行。&lt;/p&gt;
&lt;p&gt;核心在于 原始问题，完整计划，历史步骤和结果，当前步骤 这整个思路&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Reflection：&lt;/strong&gt; 一种赋予智能体“反思”能力的范式，通过自我批判和修正来优化结果。&lt;/p&gt;
&lt;p&gt;先完成整个问题，再审视前面的结果进行反思，常见会通过 ”事实错误，逻辑漏洞，效率问题，遗漏信息等“ 多个常见的不同角度进行反思，对初稿进行反复修改，形成更完善的修订稿。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个具体的步骤有一个共同的system prompt和不同的user prompt，user prompt会结合当前任务描述，上个步骤的思考行动输入观察，以及当前的执行计划生成。&lt;/p&gt;
&lt;h2 id="client"&gt;&lt;a href="#client" class="header-anchor"&gt;&lt;/a&gt;client
&lt;/h2&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-txt" data-lang="txt"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;client
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - base_client： 抽象基类
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - send_recv： 向LLM API发送和接收消息
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - extract_txt：从响应消息中提取文本
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - chat：send_recv and extract_txt
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id="tools"&gt;&lt;a href="#tools" class="header-anchor"&gt;&lt;/a&gt;tools
&lt;/h2&gt;&lt;p&gt;核心工具模块，提供了智能体（Agent）可调用的各类工具函数，支持文件操作、代码执行、代码分析等核心功能，是智能体与外部环境交互的主要接口。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-txt" data-lang="txt"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;file_tools
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - create_file 创建或者覆盖文本文件
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - read_file 读取文件内容
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - list_directory 列出当前目录内容
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - edit_file 编辑文件的指定行（插入，替换，删除）
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - search_in_file 在文件中搜索文本or正则表达式，支持上下文显示
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;execution_tools
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - run_python 运行python代码or脚本
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - run_shell 运行shell命令
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - run_tests 运行python测试套件
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - run_linter 运行代码检查/格式化工具
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;code_analysis_tools
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - parse_ast 解析Python文件的AST抽象语法树提取代码信息
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - get_function_signature 提取指定函数的签名
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - find_dependencies 分析文件的依赖关系
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - get_code_metrics 获取代码度量信息
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id="prompt"&gt;&lt;a href="#prompt" class="header-anchor"&gt;&lt;/a&gt;prompt
&lt;/h2&gt;&lt;p&gt;提示词的基本要素在于：指令（模型需要执行的任务或命令），上下文（包含的外部信息或者额外的上下文信息），输入数据，输出指示。&lt;/p&gt;
&lt;p&gt;另外更加具体的描述：可以在提示词中添加角色，可用的额外工具，少量的样本提示等，以期达到最好的效果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;角色定义&lt;/li&gt;
&lt;li&gt;工具清单（tools）&lt;/li&gt;
&lt;li&gt;格式规约（thought/action）&lt;/li&gt;
&lt;li&gt;动态上下文（memory）&lt;/li&gt;
&lt;li&gt;少样本提示&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="memory"&gt;&lt;a href="#memory" class="header-anchor"&gt;&lt;/a&gt;memory
&lt;/h2&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-txt" data-lang="txt"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;context_compressor
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - should_compress 当对话轮数大于a时，需要压缩
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - compress 保留最近b条对话和第1条系统prompt，其余压缩
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - _extract_key_information 提取(a-b-1)条信息的摘要，包括文件路径，执行工具，错误信息，任务完成情况四类
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - get_compression_status 获取压缩信息（原信息，压缩后信息，压缩率，节省的消息数量）
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id="mcp"&gt;&lt;a href="#mcp" class="header-anchor"&gt;&lt;/a&gt;mcp
&lt;/h2&gt;&lt;p&gt;Model Context Protocol 是一个开放协议，它规范了应用程序如何为 LLMs 提供上下文。可以将 MCP 想象为 AI 应用的 USB-C 端口。就像 USB-C 提供了一种标准方式，让你的设备连接到各种外设和配件，MCP 也提供了一种标准方式，让你的 AI 模型连接到不同的数据源和工具。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-txt" data-lang="txt"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;playwright
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - 提供全栈浏览器自动化能力，支持模拟用户在浏览器中的各类操作。
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - 比如网页导航，交互操作，截图，生成pdf等
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Context7
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - 增强代码代理对长上下文的理解与处理能力，提供语义搜索和上下文压缩。
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Filesystem
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - 提供高级文件系统交互能力，扩展基础文件操作的边界。
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Puppeteer
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - 基于 Chrome 内核的浏览器自动化工具，与 Playwright 功能类似但专注于 Chromium。
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;SQLite
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - 提供轻量级数据库交互能力，无需额外部署数据库服务。
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-txt" data-lang="txt"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;MCP Client: 和单个服务器通信，建立连接，发送请求和处理响应
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;MCP Config: MCP服务器的配置结构，从json配置加载，保存和解析
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;MCP Manager: 多MCP服务器的管理
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;MCP Client：&lt;/p&gt;
&lt;p&gt;在MCP客户端采用JSON-RPC格式发送请求，作为标准客户端和服务器之间的通信方式。&lt;/p&gt;
&lt;p&gt;JSON-RPC是一种基于JSON的简单远程过程调用协议。MCP客户端可以同时发送多个请求，服务器响应一般为无序返回，但是JSON-RPC的id字段能够确保每个响应准确对应发起的请求。&lt;/p&gt;
&lt;p&gt;因此对于每个MCP客户端都会开启一个&lt;strong&gt;线程&lt;/strong&gt;，开启线程时通过同步接收来自服务器的信息，筛选其中为该&lt;strong&gt;MCP客户端id&lt;/strong&gt;相同的信息，然后将接收到的完整信息放入&lt;strong&gt;输出队列&lt;/strong&gt;之中。每个线程会拥有一个&lt;strong&gt;互斥锁&lt;/strong&gt;，保证同一时刻只有一个线程能访问共享资源。&lt;/p&gt;
&lt;p&gt;初始化时会发送一个连接请求，以此确认连接成功同时获取可用的工具列表。&lt;/p&gt;
&lt;p&gt;MCP Manager：&lt;/p&gt;
&lt;p&gt;config中存在所有的服务器配置信息，clients中存在所有服务器名称对应的客户端&lt;/p&gt;
&lt;p&gt;启用和关闭服务器都是先通过config确认配置信息，之后通过client启用or关闭&lt;/p&gt;
&lt;p&gt;_tools_cache中存储着当前可用的工具，工具中的运行函数需要在manager中写，因为是通过client中的通信运行工具的。同时当服务器信息发生变更时，需要同步更新工具信息。&lt;/p&gt;
&lt;h2 id="core"&gt;&lt;a href="#core" class="header-anchor"&gt;&lt;/a&gt;core
&lt;/h2&gt;&lt;p&gt;re-act agent 运行流程。ReAct 框架为单步单动作循环逻辑，多动作场景会通过拆分为多个步骤来处理，而非在单个步骤中包含多个 &lt;code&gt;action&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;1 通过规划器生成流程。planner中的变量包括：step_number, action, reason, completed, result&lt;/p&gt;
&lt;p&gt;2 每个步骤都需要调用LLM API，压缩器，prompt，每个步骤具体过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;system prompt + user prompt（包括planner生成的计划完成情况，ai对上一步生成的step，上一步执行工具后的返回结果）&lt;/li&gt;
&lt;li&gt;调用API执行当前步骤得到返回结果，返回结果中存在 thought, action, action_input。&lt;/li&gt;
&lt;li&gt;将返回结果的action input通过action执行得到观察结果observation&lt;/li&gt;
&lt;li&gt;回调实时输出步骤&lt;/li&gt;
&lt;li&gt;异常情况：1 调用api错误，直接记录当前error，重新规划。2 action为已完成时，可以直接return。3 检查工具是否正确，不对则重新规划当前步骤&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>