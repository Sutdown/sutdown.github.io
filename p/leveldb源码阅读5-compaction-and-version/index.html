<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="leveldb compaction And Version 源码阅读，包括compaction机制的实现、版本管理机制的原理和应用场景。"><title>leveldb源码阅读5 Compaction And Version</title><link rel=canonical href=https://sutdown.github.io/p/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB5-compaction-and-version/><link rel=stylesheet href=/scss/style.min.e99cacdfab3d9a5b701f58688b2e6aadbc69a6f5d7ee5c79ce234e92e117e59e.css><meta property='og:title' content="leveldb源码阅读5 Compaction And Version"><meta property='og:description' content="leveldb compaction And Version 源码阅读，包括compaction机制的实现、版本管理机制的原理和应用场景。"><meta property='og:url' content='https://sutdown.github.io/p/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB5-compaction-and-version/'><meta property='og:site_name' content='Sutdown'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:published_time' content='2024-10-27T00:00:00+00:00'><meta property='article:modified_time' content='2024-10-27T00:00:00+00:00'><meta property='og:image' content='https://sutdown.github.io/images/62c77b63.jpg'><meta name=twitter:title content="leveldb源码阅读5 Compaction And Version"><meta name=twitter:description content="leveldb compaction And Version 源码阅读，包括compaction机制的实现、版本管理机制的原理和应用场景。"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://sutdown.github.io/images/62c77b63.jpg'><link rel="shortcut icon" href=/favicon.svg></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=https://avatars.githubusercontent.com/Sutdown width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Sutdown</a></h1><h2 class=site-description>白日依山尽，黄河入海流。</h2></div></header><ol class=menu-social><li><a href=https://github.com/Sutdown target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.xiaohongshu.com/user/profile/67c68dd4000000000a03f378 target=_blank title=Xiaohongshu rel=me><svg t="1768107575281" class="icon" viewBox="0 0 1024 1024" p-id="8009" width="200" height="200"><path d="M996.152 56.513c-7.986-10.852-17.61-20.885-28.871-28.87C944.143 10.442 916.09.0 885.377.0H138.419c-30.715.0-59.176 10.443-82.314 27.642-10.852 7.986-20.885 17.61-28.87 28.87C10.444 79.448.001 107.703.001 138.623V885.58c0 30.715 10.442 59.176 27.641 81.905 7.986 10.852 17.61 20.885 28.871 28.87 23.138 17.2 51.19 27.643 81.904 27.643h746.959c30.714.0 59.175-10.443 81.904-27.642 10.852-7.986 20.885-17.61 28.87-28.87 17.2-23.139 27.643-51.19 27.643-81.905V138.622c0-30.92-10.852-59.175-27.642-82.11zm-629.633 410.54c16.38-36.241 34.81-71.87 52.213-107.497h59.995c-14.743 29.28-31.124 57.947-41.566 85.794 24.366-1.433 46.48-2.662 72.484-4.095-13.923 27.847-26.209 52.623-38.494 77.398-1.639 3.276-3.277 6.757-4.915 10.033-12.9 25.8-12.9 26.004 15.767 26.62 3.071.0 5.938.41 11.466 1.022-7.985 15.767-15.152 30.1-22.728 44.228-1.229 2.253-4.71 4.915-6.962 4.915-21.09.0-42.385.614-63.475-1.639-15.152-1.638-21.09-13.309-15.152-27.642 7.166-17.814 15.766-35.219 23.752-52.828 2.662-6.143 5.528-12.08 9.42-21.09-11.673.0-20.272.206-28.872.0-24.776-1.023-33.17-12.285-22.933-35.218zM76.171 658.299c-12.695-22.114-24.16-42.59-35.832-63.065.0-2.458 22.933-72.485 17.814-151.726h63.065s2.253 148.45-45.047 214.791zm147.222-7.985c.614 37.061-24.98 37.061-24.98 37.061H162.17l-38.085-50.37h39.928v-277.45h59.994c0 90.915-.204 199.846-.614 290.76zm87.227 4.71c-28.666-25.186-44.227-100.333-43.818-211.925h59.175c-4.504 58.765 14.538 137.187 14.538 137.187s-17.404 38.495-29.895 74.737zm129.817 26.004c-1.638 3.071-6.757 5.938-10.443 6.142-27.847.41-55.9.205-87.842.205 12.081-24.16 22.114-43.818 30.92-61.018h95.621c-10.647 20.885-19.042 38.085-28.256 54.67zm244.481 6.552h-215.2c10.442-20.68 29.075-57.537 29.075-57.537h61.428V441.87h-38.29v-58.766h138.622v57.947h-37.88v189.196h62.245v57.333zm284.615-43.409c0 43.409-42.385 42.18-42.385 42.18h-55.285l-23.138-49.756 59.995.205s.614-45.047.0-60.609c-.41-13.105-7.576-21.5-20.886-21.704-26.618-.615-53.442-.205-82.722-.205v132.274h-59.38V555.1h-59.995v-61.222h58.356v-51.804h-38.7v-57.947h39.315v-24.571h59.994l.41 24.57h47.708s44.024-1.023 44.228 41.77c.205 12.697.41 54.263.41 68.187 50.575-.205 72.075 10.033 72.075 45.25V644.17zm-25.39-200.46H912.2v-30.507c0-11.057 5.528-21.295 14.947-27.233 10.647-6.757 25.39-11.057 39.314 2.252.614.41 1.024 1.024 1.433 1.638 19.247 20.27 4.095 53.852-23.752 53.852z" fill="#cdcdcd" p-id="8010"/><path d="M805.521 493.878h39.723v-52.01h-40.132z" fill="#cdcdcd" p-id="8011"/></svg></a></li><li><a href=https://www.zhihu.com/people/mcgyfw target=_blank title=Zhihu rel=me><svg t="1768107284785" class="icon" viewBox="0 0 1024 1024" p-id="2041" width="200" height="200"><path d="M351.791182 562.469462h192.945407c0-45.367257-21.3871-71.939449-21.3871-71.939449L355.897709 490.530013c3.977591-82.182744 7.541767-187.659007 8.816806-226.835262h159.282726s-.86367-67.402109-18.578124-67.402109-279.979646.0-279.979646.0 16.850783-88.141456 39.318494-127.053698c0 0-83.60514-4.510734-112.121614 106.962104S81.344656 355.077018 76.80834 367.390461s24.62791 5.832845 36.941354.0c12.313443-5.832845 68.050885-25.924439 84.252893-103.69571h86.570681c1.165546 49.28652 4.596691 200.335724 3.515057 226.835262H109.86113c-25.275663 18.147312-33.701566 71.939449-33.701566 71.939449H279.868105c-8.497535 56.255235-23.417339 128.763642-44.275389 167.210279-33.05279 60.921511-50.55235 116.65793-169.802314 212.576513.0.0-19.442818 14.257725 40.829917 9.073656 60.273758-5.185093 117.305683-20.739347 156.840094-99.807147 20.553105-41.107233 41.805128-93.250824 58.386782-146.138358l-.055259.185218 167.855986 193.263655s22.035876-51.847855 5.832845-108.880803L371.045711 650.610918l-42.1244 31.157627-.045025.151449c11.69946-41.020252 20.11206-81.5749 22.726607-116.858498C351.665315 564.212152 351.72876 563.345412 351.791182 562.469462z" fill="#777" p-id="2042"/><path d="M584.918753 182.033893v668.840094h70.318532l28.807093 80.512708 121.875768-80.512708h153.600307L959.520453 182.033893h-374.6017zM887.150192 778.934538h-79.837326l-99.578949 65.782216-23.537066-65.782216h-24.855084L659.341766 256.673847h227.807403V778.934538z" fill="#777" p-id="2043"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li><a href=/travelling/><svg class="icon" viewBox="0 0 1024 1024"><path d="M691.73 162H332.27c-78.239.0-141.892 63.648-141.892 141.892V682.27c0 36.508 29.704 66.216 66.216 66.216h56.212l-46.078 56.757L220.65 862h582.698l-46.078-56.757-46.078-56.757h56.212c36.512.0 66.216-29.709 66.216-66.216V303.892C833.622 225.648 769.969 162 691.73 162zm0 56.757c46.942.0 85.135 38.189 85.135 85.135v113.513H540.378V218.757H691.73zm-359.46.0h151.351v198.649H247.135V303.892c0-46.946 38.194-85.135 85.135-85.135zm304.599 586.486H339.834l46.078-56.757h252.176l46.078 56.757h-47.297zM767.405 691.73h-510.81c-5.127.0-9.459-4.333-9.459-9.459V474.162h529.73V682.27c-.001 5.127-4.334 9.46-9.461 9.46z" fill="#787878"/><path d="M346.459 587.676m-47.297.0a47.297 47.297.0 1094.594.0 47.297 47.297.0 10-94.594.0z" fill="#787878"/><path d="M677.541 587.676m-47.297.0a47.297 47.297.0 1094.594.0 47.297 47.297.0 10-94.594.0z" fill="#787878"/></svg>
<span>Travelling</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ul><li><a href=#compaction>compaction</a></li><li><a href=#作用leveldb---handbook>作用：leveldb - handbook</a></li><li><a href=#compaction过程>Compaction过程</a><ul><li><a href=#minor-compaction介绍>minor compaction介绍</a></li><li><a href=#major-compaction介绍>major compaction介绍</a><ul><li><a href=#错峰合并>错峰合并</a></li><li><a href=#采样检测>采样检测</a></li><li><a href=#过程>过程</a></li></ul></li></ul></li><li><a href=#compact源码分析>Compact源码分析</a><ul><li><a href=#后台线程>后台线程</a></li><li><a href=#优先级>优先级</a><ul><li><ul><li><a href=#db_implcc>db_impl.cc</a></li></ul></li><li><a href=#minor-compaction范围>Minor Compaction范围</a></li><li><a href=#major-compaction范围>Major Compaction范围</a></li></ul></li><li><a href=#后台线程中的compaction>后台线程中的compaction</a></li><li><a href=#minor-compaction>Minor Compaction</a><ul><li><a href=#触发>触发</a></li></ul></li><li><a href=#size-compaction>Size Compaction</a><ul><li><a href=#触发-1>触发</a></li></ul></li><li><a href=#seek-compaction>Seek Compaction</a><ul><li><a href=#触发-2>触发</a></li></ul></li><li><a href=#manual-compaction>Manual Compaction</a><ul><li><a href=#触发-3>触发</a></li></ul></li><li><a href=#minor-compaction执行>Minor Compaction执行</a></li><li><a href=#major-compaction执行>Major Compaction执行</a></li></ul></li></ul><ul><li><a href=#前言>前言</a></li><li><a href=#源码分析>源码分析</a><ul><li><a href=#class-compaction>class compaction</a></li><li><a href=#manifest>Manifest</a></li><li><a href=#version_edit>version_edit</a></li><li><a href=#version_set>version_set</a><ul><li><a href=#class-version>class version</a></li><li><a href=#class-versionset>class versionset</a></li></ul></li><li><a href=#recover>Recover</a></li><li><a href=#repair>Repair</a></li></ul></li></ul></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB5-compaction-and-version/><img src=/images/62c77b63.jpg loading=lazy alt="Featured image of post leveldb源码阅读5 Compaction And Version"></a></div><div class=article-details><header class=article-category><a href=/categories/leveldb/>LevelDB</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB5-compaction-and-version/>leveldb源码阅读5 Compaction And Version</a></h2><h3 class=article-subtitle>leveldb compaction And Version 源码阅读，包括compaction机制的实现、版本管理机制的原理和应用场景。</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published datetime=2024-10-27T00:00:00Z>Oct 27, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 33 分钟</time></div></footer></div></header><section class=article-content><h2 id=compaction><a href=#compaction class=header-anchor></a>compaction</h2><h2 id=作用leveldb---handbook><a href=#%e4%bd%9c%e7%94%a8leveldb---handbook class=header-anchor></a>作用：<a class=link href=https://leveldb-handbook.readthedocs.io/zh/latest/compaction.html target=_blank rel=noopener>leveldb - handbook</a></h2><ol><li><p><strong>数据持久化。<strong>一次</strong>minor compaction</strong>的产出是一个0层的sstable文件，其中包含了所有的内存数据。但是若干个0层文件中是可能存在数据overlap的。</p></li><li><p><strong>提高读写效率</strong>。<strong>Major Compaction</strong>的过程，将0层中的文件合并为若干个没有数据重叠的1层文件。对于没有数据重叠的文件，一次查找过程就可以进行优化，最多只需要一个文件的遍历即可完成。因此，leveldb设计compaction的目的之一就是为了<strong>提高读取的效率</strong>。</p></li><li><p><strong>平衡读写差异。<strong>有了minor compaction和major compaction，所有的数据在后台都会被规定的次序进行整合。但是一次major compaction的过程其本质是一个</strong>多路归并</strong>的过程，既有大量的磁盘读开销，也有大量的磁盘写开销，显然这是一个严重的性能瓶颈。</p><p>但是当用户写入的速度始终大于major compaction的速度时，就会导致0层的文件数量还是不断上升，用户的读取效率持续下降。所以leveldb中规定：</p><ul><li>当0层文件数量超过<code>SlowdownTrigger</code>时，写入的速度主要减慢；</li><li>当0层文件数量超过<code>PauseTrigger</code>时，写入暂停，直至Major Compaction完成；</li></ul></li><li><p>**整理数据。**leveldb的每一条数据项都有一个版本信息，标识着这条数据的新旧程度。这也就意味着同样一个key，在leveldb中可能存在着多条数据项，且每个数据项包含了不同版本的内容。为了尽量减少数据集所占用的磁盘空间大小，leveldb在major compaction的过程中，对不同版本的数据项进行合并。</p></li></ol><h2 id=compaction过程><a href=#compaction%e8%bf%87%e7%a8%8b class=header-anchor></a>Compaction过程</h2><h3 id=minor-compaction介绍><a href=#minor-compaction%e4%bb%8b%e7%bb%8d class=header-anchor></a>minor compaction介绍</h3><p><img src=/img/images/15.jpg loading=lazy alt=15></p><h3 id=major-compaction介绍><a href=#major-compaction%e4%bb%8b%e7%bb%8d class=header-anchor></a>major compaction介绍</h3><ul><li>Size Compaction：根据每层总SSTable大小触发（level-0根据SSTable数）的Major Compaction。</li><li>Seek Compaction：根据SSTable的seek miss触发的Major Compaction。</li><li>Manual Compaction：LevelDB使用者通过接口<code>void CompactRange(const Slice* begin, const Slice* end)</code>手动触发。</li></ul><p><img src=/img/images/16.jpg loading=lazy alt=16></p><h4 id=错峰合并><a href=#%e9%94%99%e5%b3%b0%e5%90%88%e5%b9%b6 class=header-anchor></a>错峰合并</h4><p>对于<strong>错峰合并</strong>网上是这么讲解的，我暂时还没看懂：</p><p><img src=/img/images/17.jpg loading=lazy alt=17></p><h4 id=采样检测><a href=#%e9%87%87%e6%a0%b7%e6%a3%80%e6%b5%8b class=header-anchor></a>采样检测</h4><p>每个sstable文件的元数据中，还有一个额外的字段<code>seekLeft</code>，默认为文件的大小除以16KB。leveldb<strong>在正常的数据访问时，会顺带进行采样探测</strong>。正常的数据访问包括（1）用户直接调用Get接口（2）用户使用迭代器进行访问。</p><p><strong>采样的规则：</strong></p><ul><li>记录本次访问的第一个sstable文件。</li><li>若在该文件中访问命中，则不做任何处理；若在该文件中访问不命中，则对 该文件的<code>seekLeft</code>标志做减一操作。</li><li>某一个文件的<code>seekLeft</code>标志减少到0时，触发错峰合并。</li></ul><p>故以上三种机制可以保障每次进行compaction的时候，总体开销不会呈现上升趋势。</p><h4 id=过程><a href=#%e8%bf%87%e7%a8%8b class=header-anchor></a>过程</h4><ol><li><p>寻找合适的输入文件；</p><blockquote><p>对于<em>level 0层文件数过多引发的合并场景或由于level i层文件总量过大的合并场景</em>，采用轮转的方法选择起始输入文件，记录了上一次该层合并的文件的最大key，下一次则选择在此key之后的首个文件。</p><p>对于<em>错峰合并</em>，起始输入文件则为该查询次数过多的文件。</p></blockquote></li><li><p>根据key重叠情况扩大输入文件集合；</p><p><img src=/img/images/18.jpg loading=lazy alt=18></p></li><li><p>多路合并；</p><p>多路合并的过程比较简单，即将level i层的文件，与level i+1层的文件中的数据项，按序整理之后，输出到level i+1层的若干个新文件中，即合并完成。</p><p>注意在整理的过程中，需要将冗余的数据进行清理，即同一条数据的多个版本信息，只保留最新的那一份。但是要注意，某些仍然在使用的旧版本的数据，在此时不能立刻删除，而得等到用户使用结束，释放句柄后，根据引用计数来进行清除。</p><p><img src=/img/images/19.jpg loading=lazy alt=19></p></li><li><p>积分计算；</p><p>每一次compaction都会消除若干source层的旧文件，新增source+1层的新文件，因此触发进行合并的条件状态可能也发生了变化。故在leveldb中，使用了计分牌来维护每一层文件的文件个数及数据总量信息，来<strong>挑选出下一个需要进行合并的层数</strong>。</p><p>计分的规则很简单：</p><ul><li>对于0层文件，该层的分数为文件总数／4；</li><li>对于非0层文件，该层的分数为文件数据总量／数据总量上限；</li></ul><p>将得分最高的层数记录，若该得分超过1，则为下一次进行合并的层数；</p></li></ol><blockquote><p>由于leveldb内部进行compaction时有trivial move优化，且根据内部的文件格式组织，用户在使用leveldb时，可以尽量将大批量需要写入的数据进行预排序，利用<strong>空间局部性</strong>，尽量减少多路合并的IO开销。</p></blockquote><h2 id=compact源码分析><a href=#compact%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90 class=header-anchor></a>Compact源码分析</h2><h3 id=后台线程><a href=#%e5%90%8e%e5%8f%b0%e7%ba%bf%e7%a8%8b class=header-anchor></a>后台线程</h3><p>为了防止Compaction执行时阻塞LevelDB的正常读写，LevelDB的所有Compaction都通过一个后台线程执行。接口定义在了<code>include/leveldb/env.h</code>中，在不同环境中的实现分别位于<code>util/env_windows.cc</code>与<code>env_posix.cc</code>中。</p><p>在env.h的schedule接口中，首先检测后台线程是否创建，如果没有创建创建后台线程。接下来会将任务放入后台线程的任务队列中，并通过信号量唤醒后台线程执行。创建后台线程与操作任务队列都需要通过锁来保护，因此该方法全程加锁。</p><p>后台线程会循环获取任务丢列中的任务，为了避免线程空转，在队列为空时通过信号量等待唤醒。如果队列中有任务，则获取该任务并将任务出队，然后执行任务。后台线程中操作队列的部分需要通过锁来保护，而执行任务时没有上锁，可以并行执行（但是LevelDB只使用了1个后台线程，因此Compaction仍是串行而不是并行的）。</p><h3 id=优先级><a href=#%e4%bc%98%e5%85%88%e7%ba%a7 class=header-anchor></a>优先级</h3><blockquote><p>Minor Compaction > Manual Compaction > Size Compaction > Seek Compaction</p></blockquote><blockquote><p>这里应当涉及几个问题：</p><p>1.compaction什么时候会被触发，对应代码是什么。2.触发时的先后顺序什么样子，对应什么代码。</p></blockquote><h5 id=db_implcc><a href=#db_implcc class=header-anchor></a>db_impl.cc</h5><p>在 LevelDB 的 <code>db_impl.cc</code> 文件中，主要负责处理对数据库的主要操作.</p><ol><li><strong>打开和关闭数据库</strong>：管理数据库的生命周期。</li><li><strong>读写操作</strong>：提供对键值对的插入、查找和删除功能。</li><li><strong>压缩和合并</strong>：实现后台压缩和合并的逻辑，优化存储。</li><li><strong>状态管理</strong>：维护数据库的状态，包括错误状态和后台任务的调度。</li><li><strong>事务处理</strong>：支持事务相关的操作。</li></ol><p><code>db_impl.cc</code>中的<code>void MaybeScheduleCompaction() EXCLUSIVE_LOCKS_REQUIRED(mutex_);</code>会判断是否执行Compaction：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>DBImpl</span><span class=o>::</span><span class=n>MaybeScheduleCompaction</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>mutex_</span><span class=p>.</span><span class=n>AssertHeld</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 检查是否有后台压缩任务被调度，如果有就不做操作
</span></span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>background_compaction_scheduled_</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Already scheduled 
</span></span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>shutting_down_</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// DB is being deleted; no more background compactions
</span></span></span><span class=line><span class=cl>    <span class=c1>// DB正在关闭时，不能调度任何压缩任务
</span></span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=o>!</span><span class=n>bg_error_</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Already got an error; no more changes
</span></span></span><span class=line><span class=cl>    <span class=c1>// 有错误时，不能进行任何压缩任务
</span></span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>imm_</span> <span class=o>==</span> <span class=k>nullptr</span> <span class=o>&amp;&amp;</span> <span class=n>manual_compaction_</span> <span class=o>==</span> <span class=k>nullptr</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>             <span class=o>!</span><span class=n>versions_</span><span class=o>-&gt;</span><span class=n>NeedsCompaction</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// No work to be done
</span></span></span><span class=line><span class=cl>    <span class=c1>// 没有任何待处理的压缩，则不调度压缩
</span></span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 当避免了各种不必要的操作和潜在问题时，可以调度压缩任务
</span></span></span><span class=line><span class=cl>    <span class=n>background_compaction_scheduled_</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>env_</span><span class=o>-&gt;</span><span class=n>Schedule</span><span class=p>(</span><span class=o>&amp;</span><span class=n>DBImpl</span><span class=o>::</span><span class=n>BGWork</span><span class=p>,</span> <span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>上面的最后一个if判断待处理的压缩时，<code>imm_==nullptr</code>对应的是<code>Minor Compaction</code>；然后就是<code>munual compaction</code>（手动触发），以及最后的version所需要的<code>Size Compaction</code>（某层的大小超过限制）或者<code>Seek Compaction</code>（多次寻找miss）</p><p>在versions中的对于后面两种情况的触发为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Returns true iff some level needs a compaction.
</span></span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=nf>NeedsCompaction</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Version</span><span class=o>*</span> <span class=n>v</span> <span class=o>=</span> <span class=n>current_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>     <span class=c1>// compaction_score_字段用来计算是否需要触发Size Compaction，
</span></span></span><span class=line><span class=cl>     <span class=c1>// file_to_compact_用来计算是否需要触发Seek Compaction
</span></span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>compaction_score_</span> <span class=o>&gt;=</span> <span class=mi>1</span><span class=p>)</span> <span class=o>||</span> <span class=p>(</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>file_to_compact_</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=minor-compaction范围><a href=#minor-compaction%e8%8c%83%e5%9b%b4 class=header-anchor></a>Minor Compaction范围</h4><p>在<a class=link href=https://www.siyuanblog.cn/archives/lsm-tree target=_blank rel=noopener>LSTtree</a>的基本概念中，Minor Compaction只需要将Immutable转储为SSTable并将其推送到level0即可。</p><p>而LevelDB对这一步骤进行优化，其会将MinorCompaction生成的SSTable推至更高的层级。</p><ol><li><p>为什么要推到更高的层级，这个步骤不是major compaction要做的吗</p><p><code>major compaction</code>需要对level中的多个文件进行复杂的合并和去重，涉及复杂的键比较和重复数据的处理，同时需要对Manifest进行频繁的更新去记录新的文件和合并后的状态，也有复杂的IO操作，开销较大。</p><p><code>minor compaction</code>只需要将memtable的数据进行写入即可，memtable也通常较小，不涉及复杂的操作，有利于提升性能。</p></li><li><p>关于推到更高的层级最多也只能是两层的解释。</p><p>level0层的文件通常是无序的，往上的更高层级则要求文件按照键进行排序。</p><p>通常是对于数据进行读取和去重然后推送到更高的层级。随着层级的提高，文件数量越来越少，但是文件的数据量更多，访问的数据块也越多，这会增加IO开销。</p><p>进行minor compaction时，本身文件量并不高，推导更高的层级反而导致了更大的开销，得不偿失。</p></li></ol><p>那如何确定讲memtable中的数据存放在哪个层级，看下面的代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*确立memtable输出的数据应该存放哪个层级*/</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>Version</span><span class=o>::</span><span class=n>PickLevelForMemTableOutput</span><span class=p>(</span><span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>smallest_user_key</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                        <span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>largest_user_key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>level</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 看level0是否与memtable输出的键有重叠，如果没有，继续向下查找
</span></span></span><span class=line><span class=cl>  <span class=c1>// 没有重叠向下查找是为了确保多个层级之间都没有重叠，减少对于major的调用，提升性能
</span></span></span><span class=line><span class=cl>  <span class=c1>// 存在重叠的愿意按：多版本的不同数据，同一个文件的多个用户间，文件分布不均等
</span></span></span><span class=line><span class=cl>  <span class=c1>// major就是拿来处理层与层之间的重叠，进而定期优化清理层级结构。
</span></span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>OverlapInLevel</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>smallest_user_key</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>largest_user_key</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Push to next level if there is no overlap in next level,
</span></span></span><span class=line><span class=cl>    <span class=c1>// and the #bytes overlapping in the level after that are limited.
</span></span></span><span class=line><span class=cl>    <span class=n>InternalKey</span> <span class=nf>start</span><span class=p>(</span><span class=n>smallest_user_key</span><span class=p>,</span> <span class=n>kMaxSequenceNumber</span><span class=p>,</span> <span class=n>kValueTypeForSeek</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>InternalKey</span> <span class=nf>limit</span><span class=p>(</span><span class=n>largest_user_key</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>ValueType</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>FileMetaData</span><span class=o>*&gt;</span> <span class=n>overlaps</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 循环遍历，直到达到最大内存压缩层级
</span></span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>level</span> <span class=o>&lt;</span> <span class=n>config</span><span class=o>::</span><span class=n>kMaxMemCompactLevel</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>OverlapInLevel</span><span class=p>(</span><span class=n>level</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>smallest_user_key</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>largest_user_key</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span> <span class=c1>// 有重叠时保持当层级退出
</span></span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 如下面两层的重叠字数超过最大值时，容易导致性能问题，层级不能上升
</span></span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>level</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>&lt;</span> <span class=n>config</span><span class=o>::</span><span class=n>kNumLevels</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Check that file does not overlap too many grandparent bytes.
</span></span></span><span class=line><span class=cl>        <span class=n>GetOverlappingInputs</span><span class=p>(</span><span class=n>level</span> <span class=o>+</span> <span class=mi>2</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>start</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>limit</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>overlaps</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=kt>int64_t</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>TotalFileSize</span><span class=p>(</span><span class=n>overlaps</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>sum</span> <span class=o>&gt;</span> <span class=n>MaxGrandParentOverlapBytes</span><span class=p>(</span><span class=n>vset_</span><span class=o>-&gt;</span><span class=n>options_</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=n>level</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>level</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>紧接着就又存在了一个问题，minor compaction和major compaction的执行过程究竟哪里不同，才会导致它们在不同的情况下使用。这个后面会结合代码解释，先大致说说。</p></blockquote><p><strong>Major Compaction</strong></p><ul><li><strong>目的</strong>: Major Compaction 主要是将 Level 0 中的所有文件合并到 Level 1，并将 Level 1 中的文件合并到 Level 2，以减少文件数量和重叠，提高查找效率。</li><li>执行过程<ol><li><strong>选择文件</strong>: 选择需要合并的文件，通常是 Level 0 中的所有文件。</li><li><strong>读取数据</strong>: 读取所有选择的文件的数据，可能涉及多个文件的内容。</li><li><strong>去重和排序</strong>: 对读取到的所有键值对进行去重和排序，以确保合并后的文件是有序的。</li><li><strong>写入新文件</strong>: 将合并后的数据写入新文件，并将其放入更高层级（如 Level 1）。</li><li><strong>更新状态</strong>: 更新 Manifest 文件，记录新文件的位置和状态。</li><li><strong>删除旧文件</strong>: 旧的合并文件会被删除，释放存储空间。</li></ol></li></ul><p><strong>Minor Compaction</strong></p><ul><li><strong>目的</strong>: Minor Compaction 主要是将 MemTable 中的数据写入 Level 0，并将 Level 0 中的一些文件推送到更高层级（如 Level 1），通常处理较小的数据量。</li><li>执行过程<ol><li><strong>选择 MemTable</strong>: 从 MemTable 中选择数据进行写入。</li><li><strong>写入 Level 0</strong>: 将 MemTable 中的数据直接写入 Level 0 的新文件。</li><li><strong>合并操作</strong>: 在 Level 0 中，可能会选择一些文件进行简单的合并（如果有）。</li><li><strong>更新状态</strong>: 更新 Manifest 文件，记录新文件的位置。</li><li><strong>释放空间</strong>: 旧的 MemTable 数据被替换或清理。</li></ol></li></ul><h4 id=major-compaction范围><a href=#major-compaction%e8%8c%83%e5%9b%b4 class=header-anchor></a>Major Compaction范围</h4><p>LevelDB在进行Major Compaction时，至少需要确定以下参数：</p><ol><li>确定Compaction起始层级i，通常为level0，因为该层数量最多最容易重叠。</li><li>确定level_i层SSTable input，识别需要合并的sstable文件。</li><li>找到i+1层中与当前层级中，没有合并的sstable存在重叠的文件，讲这些重叠文件和当前文件一起处理生成新的文件放在i+1层文件中。</li></ol><p>由于三种Major Compaction的起始条件与目标都不同，其确定这三个参数的方式稍有不同。</p><h3 id=后台线程中的compaction><a href=#%e5%90%8e%e5%8f%b0%e7%ba%bf%e7%a8%8b%e4%b8%ad%e7%9a%84compaction class=header-anchor></a>后台线程中的compaction</h3><p><code>DBImpl::BGWork</code>是后台线程的执行入口。具体情况从代码中分析：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*将db通过类型转换程DBImpl，然后调用BackGroundCall接口，启动和调度后台处理任务。*/</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>DBImpl</span><span class=o>::</span><span class=n>BGWork</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>db</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>DBImpl</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>db</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>BackgroundCall</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*处理levelDB的后台任务*/</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>DBImpl</span><span class=o>::</span><span class=n>BackgroundCall</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>MutexLock</span> <span class=nf>l</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_</span><span class=p>);</span> <span class=c1>// 创建互斥锁，保证线程安全。
</span></span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>background_compaction_scheduled_</span><span class=p>);</span> <span class=c1>// 确保后台有任务被调度
</span></span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>shutting_down_</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// No more background work when shutting down.
</span></span></span><span class=line><span class=cl>    <span class=c1>// 数据库正在关闭时不执行任何后台工作，避免关闭过程中继续处理数据导致数据损坏
</span></span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=o>!</span><span class=n>bg_error_</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// No more background work after a background error.
</span></span></span><span class=line><span class=cl>    <span class=c1>// 排除后台错误
</span></span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 执行合并操作，将levelDB中的数据整理并优化到适当的层级
</span></span></span><span class=line><span class=cl>    <span class=c1>// 只要满足条件触发合并，这个过程就会不断被调用
</span></span></span><span class=line><span class=cl>    <span class=c1>// 首次遍历，优化存储，减少重叠文件和荣誉数据
</span></span></span><span class=line><span class=cl>    <span class=n>BackgroundCompaction</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 重置调度装置，表示任务完成，避免重复执行同一个合并任务
</span></span></span><span class=line><span class=cl>  <span class=n>background_compaction_scheduled_</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Previous compaction may have produced too many files in a level,
</span></span></span><span class=line><span class=cl>  <span class=c1>// so reschedule another compaction if needed.
</span></span></span><span class=line><span class=cl>  <span class=n>MaybeScheduleCompaction</span><span class=p>();</span> <span class=c1>// 检查是否需要重新调度合并，对sstable文件数量进行评估
</span></span></span><span class=line><span class=cl>  <span class=n>background_work_finished_signal_</span><span class=p>.</span><span class=n>SignalAll</span><span class=p>();</span> <span class=c1>// 唤醒等待线程，可以促进触发新的合并
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>我还挺好奇，<code>BackgroundCompaction</code>和<code>MaybeScheduleCompaction</code>的具体差异，后者前面分析过了，有待处理的压缩比如minor compaction或者major compaction时会调用。</p><p>看看BackgroundCompaction()这个函数：代码比较长，这里就叙述一下大致逻辑：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*leveldb的核心部分，涵盖了合并的选择，执行和状态管理*/</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>DBImpl</span><span class=o>::</span><span class=n>BackgroundCompaction</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 上锁保障线程安全
</span></span></span><span class=line><span class=cl>    <span class=n>mutex_</span><span class=p>.</span><span class=n>AssertHeld</span><span class=p>();</span>  
</span></span><span class=line><span class=cl>    <span class=c1>// 处理尚未合并的immutable memetable
</span></span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>imm_</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>        <span class=n>CompactMemTable</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 处理尚未合并的 munual compaction
</span></span></span><span class=line><span class=cl>    <span class=c1>// 根据is_munual选择对c进行手动合并还是自动合并
</span></span></span><span class=line><span class=cl>    <span class=n>Compaction</span><span class=o>*</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>is_manual</span> <span class=o>=</span> <span class=p>(</span><span class=n>manual_compaction_</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 对c进行再次检查的主要原因是为了确保合并操作的完整性和正确性。
</span></span></span><span class=line><span class=cl>    <span class=c1>// 第一次合并主要是处理选择出来的SSTable文件，执行合并操作。
</span></span></span><span class=line><span class=cl>    <span class=c1>// 第二次目的是确认合并结果
</span></span></span><span class=line><span class=cl>    <span class=n>Status</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*c为空时，跳过；
</span></span></span><span class=line><span class=cl><span class=cm>      当前任务不是mutual compaction，则判断是不是is_trivial move(只需要从一层移动到下一层)，既不需要合并也不需要拆分SSTable，只通过Versionset修改一下level的文件编号即可。
</span></span></span><span class=line><span class=cl><span class=cm>      否则，执行compaction的操作，依次执行DoCompactionWork、CleanupCompaction、RemoveObsoleteFiles。*/</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>c</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Nothing to do 没有合并文件
</span></span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=o>!</span><span class=n>is_manual</span> <span class=o>&amp;&amp;</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>IsTrivialMove</span><span class=p>())</span> <span class=p>{...}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=c1>// 错误处理，状态更新
</span></span></span><span class=line><span class=cl><span class=p>}</span>     
</span></span><span class=line><span class=cl><span class=c1>// is_manual为1则是手动合并，为0则是自动合并。
</span></span></span></code></pre></td></tr></table></div></div><p>至于<code>Compaction::IsTrivialMove</code>的实现:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*判断当前的操作是否可以简单移动*/</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>Compaction</span><span class=o>::</span><span class=n>IsTrivialMove</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>VersionSet</span><span class=o>*</span> <span class=n>vset</span> <span class=o>=</span> <span class=n>input_version_</span><span class=o>-&gt;</span><span class=n>vset_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Avoid a move if there is lots of overlapping grandparent data.
</span></span></span><span class=line><span class=cl>  <span class=c1>// Otherwise, the move could create a parent file that will require
</span></span></span><span class=line><span class=cl>  <span class=c1>// a very expensive merge later on.
</span></span></span><span class=line><span class=cl>  <span class=c1>// 当前层有文件而下一层没有文件，因为这确保了移动不会引入重叠，并简化了未来的合并流程
</span></span></span><span class=line><span class=cl>  <span class=c1>// 如果在进行简单移动时，当前层的文件与祖父层的文件重叠过多，这可能导致在未来需要进行昂贵的合并操作
</span></span></span><span class=line><span class=cl>  <span class=c1>// 如果当前层与下一层之间的重叠较少，则在合并时主要关注当前层和下一层之间的关系，而与祖父层的关系相对较小。也就是让祖父层和下一层重叠多是一个很糟的决定
</span></span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span><span class=n>num_input_files</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>num_input_files</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>          <span class=n>TotalFileSize</span><span class=p>(</span><span class=n>grandparents_</span><span class=p>)</span> <span class=o>&lt;=</span>
</span></span><span class=line><span class=cl>              <span class=n>MaxGrandParentOverlapBytes</span><span class=p>(</span><span class=n>vset</span><span class=o>-&gt;</span><span class=n>options_</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=minor-compaction><a href=#minor-compaction class=header-anchor></a>Minor Compaction</h3><p>对于该步的直接理解在于，从immutable memtable转换成磁盘中的sstable文件，接下来看看具体过程。</p><h4 id=触发><a href=#%e8%a7%a6%e5%8f%91 class=header-anchor></a>触发</h4><p>首先我们了解一下Memtable转换成Immutable Memtable的过程，这个是在<code>DBImpl::MakeRoomForWrite</code>中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>leveldb是流控和等待的方式。
</span></span></span><span class=line><span class=cl><span class=cm>在这个函数中，通过综合内存管理和文件状态，确保leveldb在写入时的高效性。
</span></span></span><span class=line><span class=cl><span class=cm>在循环写入的过程中，会对不同的情况进行判断，比如
</span></span></span><span class=line><span class=cl><span class=cm>1.level0文件数量接近上限(默认为8，超过4时会触发minor compaction），开始对写入操作施加延迟，减少坚持波动给压缩线程留出时间
</span></span></span><span class=line><span class=cl><span class=cm>2.内存表有足够空间时，继续写入，memtable有空间
</span></span></span><span class=line><span class=cl><span class=cm>3.内存表已满，并且之前的内存表正在压缩（memtable已满，immutable memtable没有完成minor compaction），等待
</span></span></span><span class=line><span class=cl><span class=cm>4.磁盘中level0文件太多，超过8时，等待
</span></span></span><span class=line><span class=cl><span class=cm>5.切换到新的内存表，压缩之前的内存表，更新状态
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></td></tr></table></div></div><p>在触发Minor Compaction前，就切断到新的WAL写入，如果Minor Compaction失败，就需要从这之前的WAL中恢复；如果Minor Compacton没有完成，leveldb不会删除旧的WAL，因此不会出现数据丢失问题，LevelDB这样做是为了在保证安全地情况下，避免Minor Compaction操作阻塞对LevelDB的正常读写。</p><h3 id=size-compaction><a href=#size-compaction class=header-anchor></a>Size Compaction</h3><h4 id=触发-1><a href=#%e8%a7%a6%e5%8f%91-1 class=header-anchor></a>触发</h4><p>在非level0层根据总的sstable大小触发，在level0层根据该层的sstable数触发。也就是说只有发生了<code>Compaction</code>，才有可能触发<code>Size Compaction</code>.</p><p><code>Compaction</code>的执行会导致Version的更新，因此LevelDB在<code>VersionSet::LogAndApply</code>方法更新<code>Version</code>之后，让其调用VersionSet::Finalize计算每层SSTable看是否需要SIze，然后选出最需要size compaction的层作为下次目标。</p><p>(这个应该就是根据每层的sstable的数量进行触发，当到达边缘时，会重排进行一些整体，具体操作后面讲，先看看触发条件)</p><p>在后台线程的<code>DBImpl::BackgroundCall</code>方法中，该方法在完成Compaction操作后，会再次调用<code>MaybeScheduleComapction</code>方法，触发上次因Compaction而需要的Size Compaction操作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>DBImpl</span><span class=o>::</span><span class=n>BackgroundCall</span><span class=p>()</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>  <span class=c1>// ... ...
</span></span></span><span class=line><span class=cl>  <span class=c1>// Previous compaction may have produced too many files in a level,
</span></span></span><span class=line><span class=cl>  <span class=c1>// so reschedule another compaction if needed.
</span></span></span><span class=line><span class=cl>  <span class=n>MaybeScheduleCompaction</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>background_work_finished_signal_</span><span class=p>.</span><span class=n>SignalAll</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=seek-compaction><a href=#seek-compaction class=header-anchor></a>Seek Compaction</h3><h4 id=触发-2><a href=#%e8%a7%a6%e5%8f%91-2 class=header-anchor></a>触发</h4><p><img src=/img/images/20.jpg loading=lazy alt=20></p><p>当leveldb查找key时，会记录一些统计信息。当在SSTable上查找时，会记录发生<code>seekmiss</code>的SSTable，这样更新<code>version</code>中相应的<code>FileMetaData</code>中的<code>allowed_seeks</code>字段，并且通过<code>MaybeScheduleCompaction</code>检查是否需要触发<code>Seek Compaction</code>。</p><p>在<code>DBImpl::Get</code>函数(读取）中，每次读取会对更新的信息进行统计，然后再判断是否需要进行seek compaction，以下为代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Status</span> <span class=n>DBImpl</span><span class=o>::</span><span class=n>Get</span><span class=p>(</span><span class=k>const</span> <span class=n>ReadOptions</span><span class=o>&amp;</span> <span class=n>options</span><span class=p>,</span> <span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>*</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Status</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>MutexLock</span> <span class=nf>l</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_</span><span class=p>);</span> <span class=c1>// 加锁保护
</span></span></span><span class=line><span class=cl>  <span class=n>SequenceNumber</span> <span class=n>snapshot</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>options</span><span class=p>.</span><span class=n>snapshot</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>snapshot</span> <span class=o>=</span> <span class=c1>// 确认快照
</span></span></span><span class=line><span class=cl>        <span class=k>static_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>SnapshotImpl</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>options</span><span class=p>.</span><span class=n>snapshot</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>sequence_number</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>snapshot</span> <span class=o>=</span> <span class=n>versions_</span><span class=o>-&gt;</span><span class=n>LastSequence</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>MemTable</span><span class=o>*</span> <span class=n>mem</span> <span class=o>=</span> <span class=n>mem_</span><span class=p>;</span> <span class=c1>// 获取当前的内存表和不可变内存表
</span></span></span><span class=line><span class=cl>  <span class=n>MemTable</span><span class=o>*</span> <span class=n>imm</span> <span class=o>=</span> <span class=n>imm_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Version</span><span class=o>*</span> <span class=n>current</span> <span class=o>=</span> <span class=n>versions_</span><span class=o>-&gt;</span><span class=n>current</span><span class=p>();</span> <span class=c1>// 当前版本的引用
</span></span></span><span class=line><span class=cl>  <span class=n>mem</span><span class=o>-&gt;</span><span class=n>Ref</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>imm</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=n>imm</span><span class=o>-&gt;</span><span class=n>Ref</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>current</span><span class=o>-&gt;</span><span class=n>Ref</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>have_stat_update</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Version</span><span class=o>::</span><span class=n>GetStats</span> <span class=n>stats</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Unlock while reading from files and memtables
</span></span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>mutex_</span><span class=p>.</span><span class=n>Unlock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// First look in the memtable, then in the immutable memtable (if any).
</span></span></span><span class=line><span class=cl>    <span class=n>LookupKey</span> <span class=nf>lkey</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>snapshot</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>mem</span><span class=o>-&gt;</span><span class=n>Get</span><span class=p>(</span><span class=n>lkey</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Done 先在当前内存表找
</span></span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>imm</span> <span class=o>!=</span> <span class=k>nullptr</span> <span class=o>&amp;&amp;</span> <span class=n>imm</span><span class=o>-&gt;</span><span class=n>Get</span><span class=p>(</span><span class=n>lkey</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Done 再在不可变内存表中找
</span></span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 最后在当前版本的SSTable文件中查找
</span></span></span><span class=line><span class=cl>      <span class=n>s</span> <span class=o>=</span> <span class=n>current</span><span class=o>-&gt;</span><span class=n>Get</span><span class=p>(</span><span class=n>options</span><span class=p>,</span> <span class=n>lkey</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stats</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>have_stat_update</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>mutex_</span><span class=p>.</span><span class=n>Lock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 如果查找时更新了统计信息，调用MaybeScheduleCompaction决定是否需要进行压缩
</span></span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>have_stat_update</span> <span class=o>&amp;&amp;</span> <span class=n>current</span><span class=o>-&gt;</span><span class=n>UpdateStats</span><span class=p>(</span><span class=n>stats</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>MaybeScheduleCompaction</span><span class=p>();</span> <span class=c1>// 这个会对各种压缩是否需要进行检查
</span></span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 解除引用计数
</span></span></span><span class=line><span class=cl>  <span class=n>mem</span><span class=o>-&gt;</span><span class=n>Unref</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>imm</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=n>imm</span><span class=o>-&gt;</span><span class=n>Unref</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>current</span><span class=o>-&gt;</span><span class=n>Unref</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在<code>Version::Get</code>中，逐层遍历覆盖了给定的<code>lookupkey</code>的sstable，同时调用match判断是否有我们想要查找的<code>internalkey</code>，即如果发生了seek就会调用<code>match</code>。</p><p>如果<code>sstable</code>中没有该key，则会继续查找，当找到了key时返回false。<code>Match</code>还会记录第一次<code>seek miss</code>的SSTable。<code>DBImpl::Get</code>会将SSTable的<code>allowed_seeks</code>减1，<code>MaybeScheduleCompaction</code>检查是否需要触发<code>Seek Compaction</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Status</span> <span class=n>Version</span><span class=o>::</span><span class=n>Get</span><span class=p>(</span><span class=k>const</span> <span class=n>ReadOptions</span><span class=o>&amp;</span> <span class=n>options</span><span class=p>,</span> <span class=k>const</span> <span class=n>LookupKey</span><span class=o>&amp;</span> <span class=n>k</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>*</span> <span class=n>value</span><span class=p>,</span> <span class=n>GetStats</span><span class=o>*</span> <span class=n>stats</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>stats</span><span class=o>-&gt;</span><span class=n>seek_file</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>stats</span><span class=o>-&gt;</span><span class=n>seek_file_level</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=nc>State</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Saver</span> <span class=n>saver</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>GetStats</span><span class=o>*</span> <span class=n>stats</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>ReadOptions</span><span class=o>*</span> <span class=n>options</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Slice</span> <span class=n>ikey</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>FileMetaData</span><span class=o>*</span> <span class=n>last_file_read</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>last_file_read_level</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>VersionSet</span><span class=o>*</span> <span class=n>vset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Status</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>found</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>bool</span> <span class=nf>Match</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>,</span> <span class=kt>int</span> <span class=n>level</span><span class=p>,</span> <span class=n>FileMetaData</span><span class=o>*</span> <span class=n>f</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>State</span><span class=o>*</span> <span class=n>state</span> <span class=o>=</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>State</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 没有找到文件时，记录当前文件和层级
</span></span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>state</span><span class=o>-&gt;</span><span class=n>stats</span><span class=o>-&gt;</span><span class=n>seek_file</span> <span class=o>==</span> <span class=k>nullptr</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>          <span class=n>state</span><span class=o>-&gt;</span><span class=n>last_file_read</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 检查是否有文件已经被访问过
</span></span></span><span class=line><span class=cl>        <span class=c1>// We have had more than one seek for this read.  Charge the 1st file.
</span></span></span><span class=line><span class=cl>        <span class=n>state</span><span class=o>-&gt;</span><span class=n>stats</span><span class=o>-&gt;</span><span class=n>seek_file</span> <span class=o>=</span> <span class=n>state</span><span class=o>-&gt;</span><span class=n>last_file_read</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>state</span><span class=o>-&gt;</span><span class=n>stats</span><span class=o>-&gt;</span><span class=n>seek_file_level</span> <span class=o>=</span> <span class=n>state</span><span class=o>-&gt;</span><span class=n>last_file_read_level</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=n>state</span><span class=o>-&gt;</span><span class=n>last_file_read</span> <span class=o>=</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>state</span><span class=o>-&gt;</span><span class=n>last_file_read_level</span> <span class=o>=</span> <span class=n>level</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>// 使用tablecache从缓存中获取数据
</span></span></span><span class=line><span class=cl>      <span class=n>state</span><span class=o>-&gt;</span><span class=n>s</span> <span class=o>=</span> <span class=n>state</span><span class=o>-&gt;</span><span class=n>vset</span><span class=o>-&gt;</span><span class=n>table_cache_</span><span class=o>-&gt;</span><span class=n>Get</span><span class=p>(</span><span class=o>*</span><span class=n>state</span><span class=o>-&gt;</span><span class=n>options</span><span class=p>,</span> <span class=n>f</span><span class=o>-&gt;</span><span class=n>number</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                <span class=n>f</span><span class=o>-&gt;</span><span class=n>file_size</span><span class=p>,</span> <span class=n>state</span><span class=o>-&gt;</span><span class=n>ikey</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                <span class=o>&amp;</span><span class=n>state</span><span class=o>-&gt;</span><span class=n>saver</span><span class=p>,</span> <span class=n>SaveValue</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>state</span><span class=o>-&gt;</span><span class=n>s</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>state</span><span class=o>-&gt;</span><span class=n>found</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>switch</span> <span class=p>(</span><span class=n>state</span><span class=o>-&gt;</span><span class=n>saver</span><span class=p>.</span><span class=n>state</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>kNotFound</span><span class=p>:</span> <span class=c1>// 继续找其它文件
</span></span></span><span class=line><span class=cl>          <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>  <span class=c1>// Keep searching in other files
</span></span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>kFound</span><span class=p>:</span> <span class=c1>// 找到键更新状态返回
</span></span></span><span class=line><span class=cl>          <span class=n>state</span><span class=o>-&gt;</span><span class=n>found</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>kDeleted</span><span class=p>:</span> <span class=c1>// 返回，键已删除
</span></span></span><span class=line><span class=cl>          <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>kCorrupt</span><span class=p>:</span> <span class=c1>// 记录错误状态返回
</span></span></span><span class=line><span class=cl>          <span class=n>state</span><span class=o>-&gt;</span><span class=n>s</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>              <span class=n>Status</span><span class=o>::</span><span class=n>Corruption</span><span class=p>(</span><span class=s>&#34;corrupted key for &#34;</span><span class=p>,</span> <span class=n>state</span><span class=o>-&gt;</span><span class=n>saver</span><span class=p>.</span><span class=n>user_key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=n>state</span><span class=o>-&gt;</span><span class=n>found</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>// Not reached. Added to avoid false compilation warnings of
</span></span></span><span class=line><span class=cl>      <span class=c1>// &#34;control reaches end of non-void function&#34;.
</span></span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>State</span> <span class=n>state</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>state</span><span class=p>.</span><span class=n>found</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>state</span><span class=p>.</span><span class=n>stats</span> <span class=o>=</span> <span class=n>stats</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>state</span><span class=p>.</span><span class=n>last_file_read</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>state</span><span class=p>.</span><span class=n>last_file_read_level</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>state</span><span class=p>.</span><span class=n>options</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>options</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>state</span><span class=p>.</span><span class=n>ikey</span> <span class=o>=</span> <span class=n>k</span><span class=p>.</span><span class=n>internal_key</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>state</span><span class=p>.</span><span class=n>vset</span> <span class=o>=</span> <span class=n>vset_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>state</span><span class=p>.</span><span class=n>saver</span><span class=p>.</span><span class=n>state</span> <span class=o>=</span> <span class=n>kNotFound</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>state</span><span class=p>.</span><span class=n>saver</span><span class=p>.</span><span class=n>ucmp</span> <span class=o>=</span> <span class=n>vset_</span><span class=o>-&gt;</span><span class=n>icmp_</span><span class=p>.</span><span class=n>user_comparator</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>state</span><span class=p>.</span><span class=n>saver</span><span class=p>.</span><span class=n>user_key</span> <span class=o>=</span> <span class=n>k</span><span class=p>.</span><span class=n>user_key</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>state</span><span class=p>.</span><span class=n>saver</span><span class=p>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>  <span class=cm>/*遍历版本中的文件，查找与给定的用户键和内部键重叠的文件，并通过回调函数处理这些文件。通过分层的方式，确保在最新文件优先的同时，也不遗漏其他层中的重叠文件。*/</span>
</span></span><span class=line><span class=cl>  <span class=n>ForEachOverlapping</span><span class=p>(</span><span class=n>state</span><span class=p>.</span><span class=n>saver</span><span class=p>.</span><span class=n>user_key</span><span class=p>,</span> <span class=n>state</span><span class=p>.</span><span class=n>ikey</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>state</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>State</span><span class=o>::</span><span class=n>Match</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>state</span><span class=p>.</span><span class=n>found</span> <span class=o>?</span> <span class=n>state</span><span class=p>.</span><span class=nl>s</span> <span class=p>:</span> <span class=n>Status</span><span class=o>::</span><span class=n>NotFound</span><span class=p>(</span><span class=n>Slice</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>get函数中，文件的访问和查找会统计访问过的文件。虽然不是直接的seek compaction，但是为后续的compaction提高了信息，判断哪些文件需要被合并以减少查找时的IO。</p><p>ForEachOverlapping函数中，查找过程会遍历多个层次的文件，通过重叠查找相关文件，这有助于进行seekcomapction时，确定哪些文件时重叠的进而决定compaction。</p><h3 id=manual-compaction><a href=#manual-compaction class=header-anchor></a>Manual Compaction</h3><h4 id=触发-3><a href=#%e8%a7%a6%e5%8f%91-3 class=header-anchor></a>触发</h4><p>Manual Comapction的触发时机比较简单。</p><p>当LevelDB的用户调用<code>DB::CompactRange</code>接口时，LevelDB会检查用户给定的Compact范围与当前状态，判断是否需要执行Manual Compaction。</p><p>如果确定执行Manual Compaction，则设置<code>manual_compaction_</code>，再调用<code>MaybeScheduleCompaction</code>方法以尝试触发Manual Compaction。</p><h3 id=minor-compaction执行><a href=#minor-compaction%e6%89%a7%e8%a1%8c class=header-anchor></a>Minor Compaction执行</h3><p>以下两个函数是imm转变为sst的过程，</p><ol><li><strong>文件添加</strong>：<code>DBImpl::WriteLevel0Table</code> 创建新的 SST 文件并将其添加到 Level 0或者其它层级。</li><li><strong>触发条件</strong>：一旦 Level 0 中的文件数量达到预设阈值，系统会自动触发 minor compaction。</li><li><strong>合并操作</strong>：在 minor compaction 过程中，Level 0 的 SST 文件会被合并并输出到 Level 1，减少 Level 0 的文件数量，提高性能。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*将imm变为SSTable，同时添加到leveldb的版本控制和文件管理。*/</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>DBImpl</span><span class=o>::</span><span class=n>CompactMemTable</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>mutex_</span><span class=p>.</span><span class=n>AssertHeld</span><span class=p>();</span> <span class=c1>// 操作期间有锁，避免并发问题（并发控制）
</span></span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>imm_</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Save the contents of the memtable as a new Table
</span></span></span><span class=line><span class=cl>  <span class=n>VersionEdit</span> <span class=n>edit</span><span class=p>;</span> <span class=c1>// 版本编辑（内存管理）
</span></span></span><span class=line><span class=cl>  <span class=n>Version</span><span class=o>*</span> <span class=n>base</span> <span class=o>=</span> <span class=n>versions_</span><span class=o>-&gt;</span><span class=n>current</span><span class=p>();</span> 
</span></span><span class=line><span class=cl>  <span class=n>base</span><span class=o>-&gt;</span><span class=n>Ref</span><span class=p>();</span> <span class=c1>// 引用版本
</span></span></span><span class=line><span class=cl>  <span class=n>Status</span> <span class=n>s</span> <span class=o>=</span> <span class=n>WriteLevel0Table</span><span class=p>(</span><span class=n>imm_</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>edit</span><span class=p>,</span> <span class=n>base</span><span class=p>);</span> <span class=c1>// 将imm写入level0，更新版本信息
</span></span></span><span class=line><span class=cl>  <span class=n>base</span><span class=o>-&gt;</span><span class=n>Unref</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 如果写入成功并且正在关闭数据库，记录错误返回
</span></span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>ok</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>shutting_down_</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>=</span> <span class=n>Status</span><span class=o>::</span><span class=n>IOError</span><span class=p>(</span><span class=s>&#34;Deleting DB during memtable compaction&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 如果没有错误，更新版本信息（错误管理）
</span></span></span><span class=line><span class=cl>  <span class=c1>// Replace immutable memtable with the generated Table
</span></span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>edit</span><span class=p>.</span><span class=n>SetPrevLogNumber</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>edit</span><span class=p>.</span><span class=n>SetLogNumber</span><span class=p>(</span><span class=n>logfile_number_</span><span class=p>);</span>  <span class=c1>// Earlier logs no longer needed
</span></span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>=</span> <span class=n>versions_</span><span class=o>-&gt;</span><span class=n>LogAndApply</span><span class=p>(</span><span class=o>&amp;</span><span class=n>edit</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mutex_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 清理空间，清理错误文件（性能优化）
</span></span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Commit to the new state
</span></span></span><span class=line><span class=cl>    <span class=n>imm_</span><span class=o>-&gt;</span><span class=n>Unref</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>imm_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>has_imm_</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>false</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>RemoveObsoleteFiles</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RecordBackgroundError</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>重点在WriteLevel0Table这个函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*要用于将内存表（MemTable）的数据写入到 Level0的SST文件中*/</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>* meta文件元数据，通过mem的迭代器保存到sst文件中
</span></span></span><span class=line><span class=cl><span class=cm>* edit描述数据库版本的更改，记录新文件的添加和删除等信息
</span></span></span><span class=line><span class=cl><span class=cm>* base当前数据库版本，参考已经存在的数据和文件信息
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=n>Status</span> <span class=n>DBImpl</span><span class=o>::</span><span class=n>WriteLevel0Table</span><span class=p>(</span><span class=n>MemTable</span><span class=o>*</span> <span class=n>mem</span><span class=p>,</span> <span class=n>VersionEdit</span><span class=o>*</span> <span class=n>edit</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                <span class=n>Version</span><span class=o>*</span> <span class=n>base</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>mutex_</span><span class=p>.</span><span class=n>AssertHeld</span><span class=p>();</span> <span class=c1>// 确保有锁
</span></span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>uint64_t</span> <span class=n>start_micros</span> <span class=o>=</span> <span class=n>env_</span><span class=o>-&gt;</span><span class=n>NowMicros</span><span class=p>();</span> <span class=c1>// 记录开始时间
</span></span></span><span class=line><span class=cl>  <span class=n>FileMetaData</span> <span class=n>meta</span><span class=p>;</span> <span class=c1>// 创建文件元数据
</span></span></span><span class=line><span class=cl>  <span class=n>meta</span><span class=p>.</span><span class=n>number</span> <span class=o>=</span> <span class=n>versions_</span><span class=o>-&gt;</span><span class=n>NewFileNumber</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>pending_outputs_</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>meta</span><span class=p>.</span><span class=n>number</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>Iterator</span><span class=o>*</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>mem</span><span class=o>-&gt;</span><span class=n>NewIterator</span><span class=p>();</span> <span class=c1>// 创建迭代器遍历内存表
</span></span></span><span class=line><span class=cl>  <span class=n>Log</span><span class=p>(</span><span class=n>options_</span><span class=p>.</span><span class=n>info_log</span><span class=p>,</span> <span class=s>&#34;Level-0 table #%llu: started&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span><span class=p>)</span><span class=n>meta</span><span class=p>.</span><span class=n>number</span><span class=p>);</span> <span class=c1>// 记录日志
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>Status</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span> <span class=c1>// 加锁建构表
</span></span></span><span class=line><span class=cl>    <span class=n>mutex_</span><span class=p>.</span><span class=n>Unlock</span><span class=p>();</span>  <span class=c1>// （理清表中有什么，meta中有什么）
</span></span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>    BuildTable 函数负责实际的写入过程。
</span></span></span><span class=line><span class=cl><span class=cm>    它将遍历迭代器中的数据，并写入到新SST文件中。
</span></span></span><span class=line><span class=cl><span class=cm>    会在指定数据库目录中创建新文件，文件名基于meta.number生成。
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>=</span> <span class=n>BuildTable</span><span class=p>(</span><span class=n>dbname_</span><span class=p>,</span> <span class=n>env_</span><span class=p>,</span> <span class=n>options_</span><span class=p>,</span> <span class=n>table_cache_</span><span class=p>,</span> <span class=n>iter</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>meta</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>mutex_</span><span class=p>.</span><span class=n>Lock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 日志记录和删除迭代器 
</span></span></span><span class=line><span class=cl>  <span class=n>Log</span><span class=p>(</span><span class=n>options_</span><span class=p>.</span><span class=n>info_log</span><span class=p>,</span> <span class=s>&#34;Level-0 table #%llu: %lld bytes %s&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span><span class=p>)</span><span class=n>meta</span><span class=p>.</span><span class=n>number</span><span class=p>,</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span><span class=p>)</span><span class=n>meta</span><span class=p>.</span><span class=n>file_size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>s</span><span class=p>.</span><span class=n>ToString</span><span class=p>().</span><span class=n>c_str</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=k>delete</span> <span class=n>iter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>pending_outputs_</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>meta</span><span class=p>.</span><span class=n>number</span><span class=p>);</span> <span class=c1>// 这个pending_outputs什么作用？
</span></span></span><span class=line><span class=cl>  <span class=c1>// 主要用于跟踪正在进行的写入操作，避免同一时刻对同一个文件进行多次写入
</span></span></span><span class=line><span class=cl>  <span class=c1>// 防止并发造成的数据破坏
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Note that if file_size is zero, the file has been deleted and
</span></span></span><span class=line><span class=cl>  <span class=c1>// should not be added to the manifest.
</span></span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>level</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// 表格构建成功，文件大小大于0
</span></span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>ok</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>meta</span><span class=p>.</span><span class=n>file_size</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Slice</span> <span class=n>min_user_key</span> <span class=o>=</span> <span class=n>meta</span><span class=p>.</span><span class=n>smallest</span><span class=p>.</span><span class=n>user_key</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Slice</span> <span class=n>max_user_key</span> <span class=o>=</span> <span class=n>meta</span><span class=p>.</span><span class=n>largest</span><span class=p>.</span><span class=n>user_key</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>base</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 根据用户键选择写入层级
</span></span></span><span class=line><span class=cl>      <span class=n>level</span> <span class=o>=</span> <span class=n>base</span><span class=o>-&gt;</span><span class=n>PickLevelForMemTableOutput</span><span class=p>(</span><span class=n>min_user_key</span><span class=p>,</span> <span class=n>max_user_key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 将文件信息添加到版本编辑中
</span></span></span><span class=line><span class=cl>    <span class=n>edit</span><span class=o>-&gt;</span><span class=n>AddFile</span><span class=p>(</span><span class=n>level</span><span class=p>,</span> <span class=n>meta</span><span class=p>.</span><span class=n>number</span><span class=p>,</span> <span class=n>meta</span><span class=p>.</span><span class=n>file_size</span><span class=p>,</span> <span class=n>meta</span><span class=p>.</span><span class=n>smallest</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=n>meta</span><span class=p>.</span><span class=n>largest</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>CompactionStats</span> <span class=n>stats</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>stats</span><span class=p>.</span><span class=n>micros</span> <span class=o>=</span> <span class=n>env_</span><span class=o>-&gt;</span><span class=n>NowMicros</span><span class=p>()</span> <span class=o>-</span> <span class=n>start_micros</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>stats</span><span class=p>.</span><span class=n>bytes_written</span> <span class=o>=</span> <span class=n>meta</span><span class=p>.</span><span class=n>file_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>stats_</span><span class=p>[</span><span class=n>level</span><span class=p>].</span><span class=n>Add</span><span class=p>(</span><span class=n>stats</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>CompactRange</code> 函数主要用于执行 <strong>minor compaction</strong>，它将 Level 0 中的 SST 文件合并到 Level 1 或更高层级。其主要作用是优化存储结构，减少 Level 0 的文件数量，提升查询和写入性能。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*处理leveldb中的范围压缩*/</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>DBImpl</span><span class=o>::</span><span class=n>CompactRange</span><span class=p>(</span><span class=k>const</span> <span class=n>Slice</span><span class=o>*</span> <span class=n>begin</span><span class=p>,</span> <span class=k>const</span> <span class=n>Slice</span><span class=o>*</span> <span class=n>end</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>max_level_with_files</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>MutexLock</span> <span class=nf>l</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Version</span><span class=o>*</span> <span class=n>base</span> <span class=o>=</span> <span class=n>versions_</span><span class=o>-&gt;</span><span class=n>current</span><span class=p>();</span> <span class=c1>// 获取当前版本
</span></span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>level</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>level</span> <span class=o>&lt;</span> <span class=n>config</span><span class=o>::</span><span class=n>kNumLevels</span><span class=p>;</span> <span class=n>level</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>base</span><span class=o>-&gt;</span><span class=n>OverlapInLevel</span><span class=p>(</span><span class=n>level</span><span class=p>,</span> <span class=n>begin</span><span class=p>,</span> <span class=n>end</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>max_level_with_files</span> <span class=o>=</span> <span class=n>level</span><span class=p>;</span> <span class=c1>// 查找有重叠的最高层级
</span></span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>TEST_CompactMemTable</span><span class=p>();</span>  <span class=c1>// TODO(sanjay): Skip if memtable does not overlap
</span></span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>level</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>level</span> <span class=o>&lt;</span> <span class=n>max_level_with_files</span><span class=p>;</span> <span class=n>level</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>TEST_CompactRange</span><span class=p>(</span><span class=n>level</span><span class=p>,</span> <span class=n>begin</span><span class=p>,</span> <span class=n>end</span><span class=p>);</span> <span class=c1>// 对每个层级进行范围压缩
</span></span></span><span class=line><span class=cl>    <span class=c1>// 将指定范围的sst文件合并，更新数据库存储结构
</span></span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>于从 Level 0 到找到的最高层级，<code>CompactRange</code> 会调用 <code>TEST_CompactRange</code> 函数，依次压缩每个层级。</p><ul><li>压缩过程：<ul><li><strong>读取文件</strong>：选择与指定范围重叠的 SST 文件。</li><li><strong>合并数据</strong>：将这些文件中的数据合并，进行排序和去重。</li><li><strong>写入新文件</strong>：将合并后的结果写入新的 SST 文件，存储在目标层级。</li><li><strong>更新版本信息</strong>：压缩完成后，更新数据库的版本信息，移除已合并的旧文件。</li></ul></li></ul><h3 id=major-compaction执行><a href=#major-compaction%e6%89%a7%e8%a1%8c class=header-anchor></a>Major Compaction执行</h3><p>关于major，我们来分析一个比较长的函数<code>DBImpl::DoCompactionWork</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*执行具体的压缩工作，从输入迭代器中读取键值对，合并数据，写入输出文件，更新版本信息*/</span>
</span></span><span class=line><span class=cl><span class=n>Status</span> <span class=n>DBImpl</span><span class=o>::</span><span class=n>DoCompactionWork</span><span class=p>(</span><span class=n>CompactionState</span><span class=o>*</span> <span class=n>compact</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>uint64_t</span> <span class=n>start_micros</span> <span class=o>=</span> <span class=n>env_</span><span class=o>-&gt;</span><span class=n>NowMicros</span><span class=p>();</span><span class=c1>// 初始化开始时间
</span></span></span><span class=line><span class=cl>  <span class=kt>int64_t</span> <span class=n>imm_micros</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=c1>// Micros spent doing imm_ compactions
</span></span></span><span class=line><span class=cl>  <span class=c1>// 记录日志
</span></span></span><span class=line><span class=cl>  <span class=n>Log</span><span class=p>(</span><span class=n>options_</span><span class=p>.</span><span class=n>info_log</span><span class=p>,</span> <span class=s>&#34;Compacting %d@%d + %d@%d files&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>compact</span><span class=o>-&gt;</span><span class=n>compaction</span><span class=o>-&gt;</span><span class=n>num_input_files</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=n>compact</span><span class=o>-&gt;</span><span class=n>compaction</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>      <span class=n>compact</span><span class=o>-&gt;</span><span class=n>compaction</span><span class=o>-&gt;</span><span class=n>num_input_files</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=n>compact</span><span class=o>-&gt;</span><span class=n>compaction</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>()</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>versions_</span><span class=o>-&gt;</span><span class=n>NumLevelFiles</span><span class=p>(</span><span class=n>compact</span><span class=o>-&gt;</span><span class=n>compaction</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>())</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>compact</span><span class=o>-&gt;</span><span class=n>builder</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>compact</span><span class=o>-&gt;</span><span class=n>outfile</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>snapshots_</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span><span class=c1>// 设置快照
</span></span></span><span class=line><span class=cl>    <span class=n>compact</span><span class=o>-&gt;</span><span class=n>smallest_snapshot</span> <span class=o>=</span> <span class=n>versions_</span><span class=o>-&gt;</span><span class=n>LastSequence</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>compact</span><span class=o>-&gt;</span><span class=n>smallest_snapshot</span> <span class=o>=</span> <span class=n>snapshots_</span><span class=p>.</span><span class=n>oldest</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>sequence_number</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 为当前版本创建一个迭代器，用于遍历待压缩的键值对
</span></span></span><span class=line><span class=cl>  <span class=n>Iterator</span><span class=o>*</span> <span class=n>input</span> <span class=o>=</span> <span class=n>versions_</span><span class=o>-&gt;</span><span class=n>MakeInputIterator</span><span class=p>(</span><span class=n>compact</span><span class=o>-&gt;</span><span class=n>compaction</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Release mutex while we&#39;re actually doing the compaction work
</span></span></span><span class=line><span class=cl>  <span class=n>mutex_</span><span class=p>.</span><span class=n>Unlock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>input</span><span class=o>-&gt;</span><span class=n>SeekToFirst</span><span class=p>();</span> <span class=c1>// 检查迭代器是否有效
</span></span></span><span class=line><span class=cl>  <span class=n>Status</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>ParsedInternalKey</span> <span class=n>ikey</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>current_user_key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>has_current_user_key</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>SequenceNumber</span> <span class=n>last_sequence_for_key</span> <span class=o>=</span> <span class=n>kMaxSequenceNumber</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>这部分就是，断言避免编码，做好日志，初始化时间等，准备数据，设置快照…然后前面是需要加锁的，然后开始解锁，设置迭代器，seq。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>  <span class=cm>/*遍历处理键值对，根据压缩的需求决定哪些键值对保留，哪些需要抛弃*/</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=n>input</span><span class=o>-&gt;</span><span class=n>Valid</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>shutting_down_</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Prioritize immutable compaction work优先处理imm
</span></span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>has_imm_</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>const</span> <span class=kt>uint64_t</span> <span class=n>imm_start</span> <span class=o>=</span> <span class=n>env_</span><span class=o>-&gt;</span><span class=n>NowMicros</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=n>mutex_</span><span class=p>.</span><span class=n>Lock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>imm_</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CompactMemTable</span><span class=p>();</span> <span class=c1>// 这个函数可以压缩不可变内存表
</span></span></span><span class=line><span class=cl>        <span class=c1>// Wake up MakeRoomForWrite() if necessary.若imm为空格，唤醒相关函数
</span></span></span><span class=line><span class=cl>        <span class=n>background_work_finished_signal_</span><span class=p>.</span><span class=n>SignalAll</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=n>mutex_</span><span class=p>.</span><span class=n>Unlock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=n>imm_micros</span> <span class=o>+=</span> <span class=p>(</span><span class=n>env_</span><span class=o>-&gt;</span><span class=n>NowMicros</span><span class=p>()</span> <span class=o>-</span> <span class=n>imm_start</span><span class=p>);</span> <span class=c1>// 记录处理不可变内存表所花费的时间
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Slice</span> <span class=n>key</span> <span class=o>=</span> <span class=n>input</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>();</span><span class=c1>// 通过迭代器获取当前键
</span></span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>compact</span><span class=o>-&gt;</span><span class=n>compaction</span><span class=o>-&gt;</span><span class=n>ShouldStopBefore</span><span class=p>(</span><span class=n>key</span><span class=p>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>        <span class=n>compact</span><span class=o>-&gt;</span><span class=n>builder</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 到达停止条件时完成写入
</span></span></span><span class=line><span class=cl>      <span class=n>status</span> <span class=o>=</span> <span class=n>FinishCompactionOutputFile</span><span class=p>(</span><span class=n>compact</span><span class=p>,</span> <span class=n>input</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>status</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Handle key/value, add to state, etc.
</span></span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>drop</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// 解析当前键，获取用户键和序列号
</span></span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>ParseInternalKey</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ikey</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Do not hide error keys 解析失败，重置相关变量
</span></span></span><span class=line><span class=cl>      <span class=n>current_user_key</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=n>has_current_user_key</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>last_sequence_for_key</span> <span class=o>=</span> <span class=n>kMaxSequenceNumber</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=c1>// 处理解析成功的键
</span></span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>has_current_user_key</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>          <span class=n>user_comparator</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>Compare</span><span class=p>(</span><span class=n>ikey</span><span class=p>.</span><span class=n>user_key</span><span class=p>,</span> <span class=n>Slice</span><span class=p>(</span><span class=n>current_user_key</span><span class=p>))</span> <span class=o>!=</span>
</span></span><span class=line><span class=cl>              <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// First occurrence of this user key
</span></span></span><span class=line><span class=cl>        <span class=n>current_user_key</span><span class=p>.</span><span class=n>assign</span><span class=p>(</span><span class=n>ikey</span><span class=p>.</span><span class=n>user_key</span><span class=p>.</span><span class=n>data</span><span class=p>(),</span> <span class=n>ikey</span><span class=p>.</span><span class=n>user_key</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=n>has_current_user_key</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>last_sequence_for_key</span> <span class=o>=</span> <span class=n>kMaxSequenceNumber</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>last_sequence_for_key</span> <span class=o>&lt;=</span> <span class=n>compact</span><span class=o>-&gt;</span><span class=n>smallest_snapshot</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Hidden by an newer entry for same user key
</span></span></span><span class=line><span class=cl>        <span class=n>drop</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>  <span class=c1>// (A)
</span></span></span><span class=line><span class=cl>      <span class=p>}</span> <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>ikey</span><span class=p>.</span><span class=n>type</span> <span class=o>==</span> <span class=n>kTypeDeletion</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                 <span class=n>ikey</span><span class=p>.</span><span class=n>sequence</span> <span class=o>&lt;=</span> <span class=n>compact</span><span class=o>-&gt;</span><span class=n>smallest_snapshot</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                 <span class=n>compact</span><span class=o>-&gt;</span><span class=n>compaction</span><span class=o>-&gt;</span><span class=n>IsBaseLevelForKey</span><span class=p>(</span><span class=n>ikey</span><span class=p>.</span><span class=n>user_key</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// For this user key:
</span></span></span><span class=line><span class=cl>        <span class=c1>// (1) there is no data in higher levels
</span></span></span><span class=line><span class=cl>        <span class=c1>// (2) data in lower levels will have larger sequence numbers
</span></span></span><span class=line><span class=cl>        <span class=c1>// (3) data in layers that are being compacted here and have
</span></span></span><span class=line><span class=cl>        <span class=c1>//     smaller sequence numbers will be dropped in the next
</span></span></span><span class=line><span class=cl>        <span class=c1>//     few iterations of this loop (by rule (A) above).
</span></span></span><span class=line><span class=cl>        <span class=c1>// Therefore this deletion marker is obsolete and can be dropped.
</span></span></span><span class=line><span class=cl>        <span class=n>drop</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=n>last_sequence_for_key</span> <span class=o>=</span> <span class=n>ikey</span><span class=p>.</span><span class=n>sequence</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>drop</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 继续处理
</span></span></span><span class=line><span class=cl>      <span class=cm>/*打开输出文件，更新输出文件最小最大键，将键值对添加到当前输出文件*/</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Open output file if necessary
</span></span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>compact</span><span class=o>-&gt;</span><span class=n>builder</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>status</span> <span class=o>=</span> <span class=n>OpenCompactionOutputFile</span><span class=p>(</span><span class=n>compact</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>status</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 如果为第一个条目，设置最小值
</span></span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>compact</span><span class=o>-&gt;</span><span class=n>builder</span><span class=o>-&gt;</span><span class=n>NumEntries</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>compact</span><span class=o>-&gt;</span><span class=n>current_output</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>smallest</span><span class=p>.</span><span class=n>DecodeFrom</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span> <span class=c1>// 更新当前条目的最大键
</span></span></span><span class=line><span class=cl>      <span class=n>compact</span><span class=o>-&gt;</span><span class=n>current_output</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>largest</span><span class=p>.</span><span class=n>DecodeFrom</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>compact</span><span class=o>-&gt;</span><span class=n>builder</span><span class=o>-&gt;</span><span class=n>Add</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>input</span><span class=o>-&gt;</span><span class=n>value</span><span class=p>());</span> <span class=c1>// 添加键值对
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>// Close output file if it is big enough 关闭输出文件
</span></span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>compact</span><span class=o>-&gt;</span><span class=n>builder</span><span class=o>-&gt;</span><span class=n>FileSize</span><span class=p>()</span> <span class=o>&gt;=</span>
</span></span><span class=line><span class=cl>          <span class=n>compact</span><span class=o>-&gt;</span><span class=n>compaction</span><span class=o>-&gt;</span><span class=n>MaxOutputFileSize</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>status</span> <span class=o>=</span> <span class=n>FinishCompactionOutputFile</span><span class=p>(</span><span class=n>compact</span><span class=p>,</span> <span class=n>input</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>status</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>input</span><span class=o>-&gt;</span><span class=n>Next</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在处理过程中，函数会优先处理不可变内存表，确保在压缩过程中不会丢失重要数据。对于每个输入键，函数会解析其内部格式并判断是否需要丢弃，基于其序列号和类型。如果键有效，就将其添加到当前的输出文件中，必要时会打开新文件并检查文件大小以决定是否完成写入。整个过程中，函数还会处理各种状态检查，并在最后记录压缩的统计信息，以便分析性能和效果。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>  <span class=cm>/*处理完成情况*/</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>status</span><span class=p>.</span><span class=n>ok</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>shutting_down_</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>status</span> <span class=o>=</span> <span class=n>Status</span><span class=o>::</span><span class=n>IOError</span><span class=p>(</span><span class=s>&#34;Deleting DB during compaction&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>status</span><span class=p>.</span><span class=n>ok</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>compact</span><span class=o>-&gt;</span><span class=n>builder</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>status</span> <span class=o>=</span> <span class=n>FinishCompactionOutputFile</span><span class=p>(</span><span class=n>compact</span><span class=p>,</span> <span class=n>input</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>status</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>status</span> <span class=o>=</span> <span class=n>input</span><span class=o>-&gt;</span><span class=n>status</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>delete</span> <span class=n>input</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>input</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*统计信息：包括压缩时间，字节读取，写入统计*/</span>
</span></span><span class=line><span class=cl>  <span class=n>CompactionStats</span> <span class=n>stats</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>stats</span><span class=p>.</span><span class=n>micros</span> <span class=o>=</span> <span class=n>env_</span><span class=o>-&gt;</span><span class=n>NowMicros</span><span class=p>()</span> <span class=o>-</span> <span class=n>start_micros</span> <span class=o>-</span> <span class=n>imm_micros</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>which</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>which</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>;</span> <span class=n>which</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>compact</span><span class=o>-&gt;</span><span class=n>compaction</span><span class=o>-&gt;</span><span class=n>num_input_files</span><span class=p>(</span><span class=n>which</span><span class=p>);</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>stats</span><span class=p>.</span><span class=n>bytes_read</span> <span class=o>+=</span> <span class=n>compact</span><span class=o>-&gt;</span><span class=n>compaction</span><span class=o>-&gt;</span><span class=n>input</span><span class=p>(</span><span class=n>which</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>file_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>compact</span><span class=o>-&gt;</span><span class=n>outputs</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>stats</span><span class=p>.</span><span class=n>bytes_written</span> <span class=o>+=</span> <span class=n>compact</span><span class=o>-&gt;</span><span class=n>outputs</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>file_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>mutex_</span><span class=p>.</span><span class=n>Lock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>stats_</span><span class=p>[</span><span class=n>compact</span><span class=o>-&gt;</span><span class=n>compaction</span><span class=o>-&gt;</span><span class=n>level</span><span class=p>()</span> <span class=o>+</span> <span class=mi>1</span><span class=p>].</span><span class=n>Add</span><span class=p>(</span><span class=n>stats</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*安装压缩结果：更新版本控制，记录错误*/</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>status</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>status</span> <span class=o>=</span> <span class=n>InstallCompactionResults</span><span class=p>(</span><span class=n>compact</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>status</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RecordBackgroundError</span><span class=p>(</span><span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*记录日志*/</span>
</span></span><span class=line><span class=cl>  <span class=n>VersionSet</span><span class=o>::</span><span class=n>LevelSummaryStorage</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Log</span><span class=p>(</span><span class=n>options_</span><span class=p>.</span><span class=n>info_log</span><span class=p>,</span> <span class=s>&#34;compacted to: %s&#34;</span><span class=p>,</span> <span class=n>versions_</span><span class=o>-&gt;</span><span class=n>LevelSummary</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tmp</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>注：</p><p>要注意一个误区是major compaction和minor compaction不是两个具体的过程。它们都是读取文件，合并数据，写入新文件，更新版本信息这几个过程。minor和major我刚开始以为是底层和高层的不同压缩，这样理解不准确，应该是微型和大型压缩更为合适。</p><p>minor相对简单，主要涉及少量文件的合并。major会涉及更多，层之内，层与层之间的文件的合并等。</p><h1 id=version><a href=#version class=header-anchor></a>version</h1><h2 id=前言><a href=#%e5%89%8d%e8%a8%80 class=header-anchor></a>前言</h2><p>leveldb每次生成或者删除sstable，都会从一个版本升级成另外一个版本。换句话说，每次都会从一个版本升级成另外一个版本。sstable的更替对于leveldb来说是一个最小的操作单元，具有原子性。。</p><p>从leveldb的角度来看，MVCC机制不仅能够并行化实现读读和读写操作，还使其能够实现快照读。用户可以通过提供的接口保留一定时间的快照，在用户释放快照前，该快照创建时leveldb中存在的数据就不会被释放。</p><p>LevelDB的多版本存储设计可分为三个层次：</p><ul><li><strong>从key/value的角度：</strong> 每次变更操作的记录（Batch Writer可视为一次操作）都有不同且递增的SequenceNumber。对于一个UserKey，当存在SequenceNumber更高的的记录时，旧的记录不会被立即删除，至少要在该SequenceNumber之前的所有Snapshot都被释放后才能删除（具体删除时间与Compaction时间有关）。这是L<strong>evelDB实现Snapshot Read的基础。</strong></li><li><strong>从MemTable的角度：</strong> LevelDB中的MemTable通过<strong>引用计数</strong>来控制释放时间。在需要读取MemTable时（无论是Get操作还是Minor Compaction时），读取前会增大其引用计数，读取后减小引用计数。这样，即使MemTable已被通过Minor Compaction操作写入到Level-0文件，<strong>MemTable在被读取，它就不会被释放</strong>，保证能被多次读。</li><li><strong>从数据库文件的角度：</strong> LevelDB的文件同样需要引用计数，当执行Major Compaction时，<strong>LevelDB不会立即删除已被合并的数据库文件，因为此时可能还有未完成的读取该文件的操作。</strong></li></ul><p><code>key/value</code>的版本实际上也是依赖于内存与稳定存储，其分别在Compaction与Put/Get操作中体现，因此这里我们主要关注后两者。</p><p><code>MemTable</code>的多版本与<code>Snapshot</code>信息是不需要直接持久化的，因为数据库关闭时无法进行Snapshot Read，也就没有了Snapshot的概念，而最新的MemTable会通过WAL重建，旧的MemTable也不再会被依赖。</p><p>数据库文件则不同，LevelDB必须记录数据库文件的版本信息，否则在数据库重启时无法快速确定哪些文件是有效的（LevelDB提供了文件版本信息损坏时的修复机制）。而<strong>LevelDB中Version及相关概念就是为此设计的。</strong></p><blockquote><p><code>VersionSet</code>是一个管理和维护多个版本的集合，</p><p>而<code>VersionEdit</code>是对版本变化的具体描述和记录。通过这种结构，LevelDB能够有效地管理数据的版本控制和变化。</p></blockquote><h2 id=源码分析><a href=#%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90 class=header-anchor></a>源码分析</h2><p><code>version_set.h</code> 文件定义了 LevelDB 中版本管理和压缩的核心数据结构。<code>Version</code> 和 <code>VersionSet</code> 类负责维护数据库的版本及其文件信息，而 <code>Compaction</code> 类则处理压缩操作。这个结构确保了 LevelDB 能高效地管理数据的版本和执行压缩策略，从而优化性能。同时相关文件有Manifest和Current。</p><h3 id=class-compaction><a href=#class-compaction class=header-anchor></a>class compaction</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Compaction</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>friend</span> <span class=k>class</span> <span class=nc>Version</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>friend</span> <span class=k>class</span> <span class=nc>VersionSet</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>Compaction</span><span class=p>(</span><span class=k>const</span> <span class=n>Options</span><span class=o>*</span> <span class=n>options</span><span class=p>,</span> <span class=kt>int</span> <span class=n>level</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>level_</span><span class=p>;</span> <span class=c1>//正在进行压缩的级别
</span></span></span><span class=line><span class=cl>  <span class=kt>uint64_t</span> <span class=n>max_output_file_size_</span><span class=p>;</span> <span class=c1>// 最大输出文件大小限制
</span></span></span><span class=line><span class=cl>  <span class=n>Version</span><span class=o>*</span> <span class=n>input_version_</span><span class=p>;</span> <span class=c1>// 指向当前压缩的输入版本
</span></span></span><span class=line><span class=cl>  <span class=n>VersionEdit</span> <span class=n>edit_</span><span class=p>;</span> <span class=c1>// 保存压缩操作所作的编辑内容，包含需要添加和删除的文件
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Each compaction reads inputs from &#34;level_&#34; and &#34;level_+1&#34;
</span></span></span><span class=line><span class=cl>  <span class=c1>// 一个存储当前级别，一个存储下一个几倍
</span></span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>FileMetaData</span><span class=o>*&gt;</span> <span class=n>inputs_</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>  <span class=c1>// The two sets of inputs
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// State used to check for number of overlapping grandparent files
</span></span></span><span class=line><span class=cl>  <span class=c1>// (parent == level_ + 1, grandparent == level_ + 2)
</span></span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>FileMetaData</span><span class=o>*&gt;</span> <span class=n>grandparents_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>grandparent_index_</span><span class=p>;</span>  <span class=c1>// Index in grandparent_starts_
</span></span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>seen_key_</span><span class=p>;</span>             <span class=c1>// Some output key has been seen
</span></span></span><span class=line><span class=cl>  <span class=kt>int64_t</span> <span class=n>overlapped_bytes_</span><span class=p>;</span>  <span class=c1>// Bytes of overlap between current output
</span></span></span><span class=line><span class=cl>                              <span class=c1>// and grandparent files
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// State for implementing IsBaseLevelForKey
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// level_ptrs_ holds indices into input_version_-&gt;levels_: our state
</span></span></span><span class=line><span class=cl>  <span class=c1>// is that we are positioned at one of the file ranges for each
</span></span></span><span class=line><span class=cl>  <span class=c1>// higher level than the ones involved in this compaction (i.e. for
</span></span></span><span class=line><span class=cl>  <span class=c1>// all L &gt;= level_ + 2).
</span></span></span><span class=line><span class=cl>  <span class=c1>// 输入版本的文件列表中为每个级别保存指向当前状态的索引
</span></span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>level_ptrs_</span><span class=p>[</span><span class=n>config</span><span class=o>::</span><span class=n>kNumLevels</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=manifest><a href=#manifest class=header-anchor></a>Manifest</h3><p>manifest文件专用于记录版本信息。leveldb采用了增量式的存储方式，记录每一个版本相较于上一个版本的变化情况。展开来说，一个Manifest文件中，包含了多条Session Record，<strong>其中第一条Session Record</strong>记载了当时leveldb的<em>全量版本信息</em>，其余若干条Session Record仅记录每次更迭的变化情况。</p><p><img src=/img/images/21.jpg loading=lazy alt=21></p><h3 id=version_edit><a href=#version_edit class=header-anchor></a>version_edit</h3><p>VersionEdit类在levelDB中与上面manifest文件管理密切相关。 manifest文件用于记录数据库的元数据和版本信息。每当数据库状态发生变化时，都会生成一个新的manifest文件，具体表现在versionset中有体现。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Tag</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>kComparator</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=c1>// 比较器的名称字符串
</span></span></span><span class=line><span class=cl>  <span class=n>kLogNumber</span> <span class=o>=</span> <span class=mi>2</span><span class=p>,</span> <span class=c1>// 文件编号
</span></span></span><span class=line><span class=cl>  <span class=n>kNextFileNumber</span> <span class=o>=</span> <span class=mi>3</span><span class=p>,</span> <span class=c1>// 下一个文件分配的编号
</span></span></span><span class=line><span class=cl>  <span class=n>kLastSequence</span> <span class=o>=</span> <span class=mi>4</span><span class=p>,</span> <span class=c1>// 当前版本的最后一个序列号
</span></span></span><span class=line><span class=cl>  <span class=n>kCompactPointer</span> <span class=o>=</span> <span class=mi>5</span><span class=p>,</span> <span class=c1>// 压缩指针
</span></span></span><span class=line><span class=cl>  <span class=n>kDeletedFile</span> <span class=o>=</span> <span class=mi>6</span><span class=p>,</span> <span class=c1>// 删除的元数据
</span></span></span><span class=line><span class=cl>  <span class=n>kNewFile</span> <span class=o>=</span> <span class=mi>7</span><span class=p>,</span> <span class=c1>// 新文件
</span></span></span><span class=line><span class=cl>  <span class=c1>// 8 was used for large value refs
</span></span></span><span class=line><span class=cl>  <span class=n>kPrevLogNumber</span> <span class=o>=</span> <span class=mi>9</span> <span class=c1>// 文件编号
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>version_edit文件</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*文件元数据，存储每个sst文件的元数据*/</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FileMetaData</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>FileMetaData</span><span class=p>()</span> <span class=o>:</span> <span class=n>refs</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=n>allowed_seeks</span><span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>30</span><span class=p>),</span> <span class=n>file_size</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>refs</span><span class=p>;</span> <span class=c1>// 引用计数
</span></span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>allowed_seeks</span><span class=p>;</span>  <span class=c1>// Seeks allowed until compaction 容易触发seek compaction
</span></span></span><span class=line><span class=cl>  <span class=kt>uint64_t</span> <span class=n>number</span><span class=p>;</span> <span class=c1>// 文件的唯一编号
</span></span></span><span class=line><span class=cl>  <span class=kt>uint64_t</span> <span class=n>file_size</span><span class=p>;</span>    <span class=c1>// File size in bytes
</span></span></span><span class=line><span class=cl>  <span class=n>InternalKey</span> <span class=n>smallest</span><span class=p>;</span>  <span class=c1>// Smallest internal key served by table 
</span></span></span><span class=line><span class=cl>  <span class=n>InternalKey</span> <span class=n>largest</span><span class=p>;</span>   <span class=c1>// Largest internal key served by table
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*记录版本的变化信息*/</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>VersionEdit</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>VersionEdit</span><span class=p>()</span> <span class=p>{</span> <span class=n>Clear</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=o>~</span><span class=n>VersionEdit</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>Clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 设置信息
</span></span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>SetComparatorName</span><span class=p>(</span><span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>has_comparator_</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>comparator_</span> <span class=o>=</span> <span class=n>name</span><span class=p>.</span><span class=n>ToString</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>SetLogNumber</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=n>num</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>has_log_number_</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>log_number_</span> <span class=o>=</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>SetPrevLogNumber</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=n>num</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>has_prev_log_number_</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>prev_log_number_</span> <span class=o>=</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>SetNextFile</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=n>num</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>has_next_file_number_</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>next_file_number_</span> <span class=o>=</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>SetLastSequence</span><span class=p>(</span><span class=n>SequenceNumber</span> <span class=n>seq</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>has_last_sequence_</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>last_sequence_</span> <span class=o>=</span> <span class=n>seq</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>SetCompactPointer</span><span class=p>(</span><span class=kt>int</span> <span class=n>level</span><span class=p>,</span> <span class=k>const</span> <span class=n>InternalKey</span><span class=o>&amp;</span> <span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>compact_pointers_</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>make_pair</span><span class=p>(</span><span class=n>level</span><span class=p>,</span> <span class=n>key</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 添加删除文件
</span></span></span><span class=line><span class=cl>  <span class=c1>// Add the specified file at the specified number.
</span></span></span><span class=line><span class=cl>  <span class=c1>// REQUIRES: This version has not been saved (see VersionSet::SaveTo)
</span></span></span><span class=line><span class=cl>  <span class=c1>// REQUIRES: &#34;smallest&#34; and &#34;largest&#34; are smallest and largest keys in file
</span></span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>AddFile</span><span class=p>(</span><span class=kt>int</span> <span class=n>level</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>file</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>file_size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>               <span class=k>const</span> <span class=n>InternalKey</span><span class=o>&amp;</span> <span class=n>smallest</span><span class=p>,</span> <span class=k>const</span> <span class=n>InternalKey</span><span class=o>&amp;</span> <span class=n>largest</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FileMetaData</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=p>.</span><span class=n>number</span> <span class=o>=</span> <span class=n>file</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=p>.</span><span class=n>file_size</span> <span class=o>=</span> <span class=n>file_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=p>.</span><span class=n>smallest</span> <span class=o>=</span> <span class=n>smallest</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=p>.</span><span class=n>largest</span> <span class=o>=</span> <span class=n>largest</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>new_files_</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>make_pair</span><span class=p>(</span><span class=n>level</span><span class=p>,</span> <span class=n>f</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Delete the specified &#34;file&#34; from the specified &#34;level&#34;.
</span></span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>RemoveFile</span><span class=p>(</span><span class=kt>int</span> <span class=n>level</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>file</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>deleted_files_</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>make_pair</span><span class=p>(</span><span class=n>level</span><span class=p>,</span> <span class=n>file</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 编码解码
</span></span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>EncodeTo</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>*</span> <span class=n>dst</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Status</span> <span class=nf>DecodeFrom</span><span class=p>(</span><span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>src</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>DebugString</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>friend</span> <span class=k>class</span> <span class=nc>VersionSet</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>set</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>uint64_t</span><span class=o>&gt;&gt;</span> <span class=n>DeletedFileSet</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>comparator_</span><span class=p>;</span> <span class=c1>//比较器名称
</span></span></span><span class=line><span class=cl>  <span class=kt>uint64_t</span> <span class=n>log_number_</span><span class=p>;</span> <span class=c1>// 日志编号
</span></span></span><span class=line><span class=cl>  <span class=kt>uint64_t</span> <span class=n>prev_log_number_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint64_t</span> <span class=n>next_file_number_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>SequenceNumber</span> <span class=n>last_sequence_</span><span class=p>;</span> <span class=c1>// 最后一个序列号
</span></span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>has_comparator_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>has_log_number_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>has_prev_log_number_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>has_next_file_number_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>has_last_sequence_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>InternalKey</span><span class=o>&gt;&gt;</span> <span class=n>compact_pointers_</span><span class=p>;</span> <span class=c1>// 存储压缩指针
</span></span></span><span class=line><span class=cl>  <span class=n>DeletedFileSet</span> <span class=n>deleted_files_</span><span class=p>;</span> <span class=c1>// 跟踪已删除的文件，便于版本更新时管理
</span></span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>FileMetaData</span><span class=o>&gt;&gt;</span> <span class=n>new_files_</span><span class=p>;</span> <span class=c1>// 存储新添加的文件信息
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>在创建新版本时，LevelDB首先构造VersionEdit，然后通过<code>VersionSet::LogAndApply</code>方法，先将VersionEdit应用到Current Version，然后将增量的VersionEdit写入Manifest文件中。</p><h3 id=version_set><a href=#version_set class=header-anchor></a>version_set</h3><p><img src=/img/images/22.jpg loading=lazy alt=22></p><h4 id=class-version><a href=#class-version class=header-anchor></a>class version</h4><p>version文件主要用于存储数据库的某个具体版本，包括当前版本的所有文件，统计信息以及相关状态。其中维护了一个文件列表记录每个层级的sst文件，不同版本之间的连接方式为双向链表；通过引用计数管理version对象的生命周期等。</p><p>同时还有和compaction相关的成员变量，</p><p>比如当前需要进行压缩的元数据以及所在层级（确定待压缩候选者）</p><p>比如当前版本的压缩评分和下一个需要压缩的层级（管理压缩的紧迫性和优先级）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Version</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>friend</span> <span class=k>class</span> <span class=nc>Compaction</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>friend</span> <span class=k>class</span> <span class=nc>VersionSet</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>LevelFileNumIterator</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>explicit</span> <span class=nf>Version</span><span class=p>(</span><span class=n>VersionSet</span><span class=o>*</span> <span class=n>vset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=o>:</span> <span class=n>vset_</span><span class=p>(</span><span class=n>vset</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>next_</span><span class=p>(</span><span class=k>this</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>prev_</span><span class=p>(</span><span class=k>this</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>refs_</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>file_to_compact_</span><span class=p>(</span><span class=k>nullptr</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>file_to_compact_level_</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>compaction_score_</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>compaction_level_</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>Version</span><span class=p>(</span><span class=k>const</span> <span class=n>Version</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Version</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Version</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=o>~</span><span class=n>Version</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>Iterator</span><span class=o>*</span> <span class=nf>NewConcatenatingIterator</span><span class=p>(</span><span class=k>const</span> <span class=n>ReadOptions</span><span class=o>&amp;</span><span class=p>,</span> <span class=kt>int</span> <span class=n>level</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Call func(arg, level, f) for every file that overlaps user_key in
</span></span></span><span class=line><span class=cl>  <span class=c1>// order from newest to oldest.  If an invocation of func returns
</span></span></span><span class=line><span class=cl>  <span class=c1>// false, makes no more calls.
</span></span></span><span class=line><span class=cl>  <span class=c1>//
</span></span></span><span class=line><span class=cl>  <span class=c1>// REQUIRES: user portion of internal_key == user_key.
</span></span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>ForEachOverlapping</span><span class=p>(</span><span class=n>Slice</span> <span class=n>user_key</span><span class=p>,</span> <span class=n>Slice</span> <span class=n>internal_key</span><span class=p>,</span> <span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>,</span> <span class=kt>bool</span> <span class=p>(</span><span class=o>*</span><span class=n>func</span><span class=p>)(</span><span class=kt>void</span><span class=o>*</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=n>FileMetaData</span><span class=o>*</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>VersionSet</span><span class=o>*</span> <span class=n>vset_</span><span class=p>;</span>  <span class=c1>// VersionSet to which this Version belongs
</span></span></span><span class=line><span class=cl>  <span class=n>Version</span><span class=o>*</span> <span class=n>next_</span><span class=p>;</span>     <span class=c1>// Next version in linked list
</span></span></span><span class=line><span class=cl>  <span class=n>Version</span><span class=o>*</span> <span class=n>prev_</span><span class=p>;</span>     <span class=c1>// Previous version in linked list
</span></span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>refs_</span><span class=p>;</span>          <span class=c1>// Number of live refs to this version
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// List of files per level
</span></span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>FileMetaData</span><span class=o>*&gt;</span> <span class=n>files_</span><span class=p>[</span><span class=n>config</span><span class=o>::</span><span class=n>kNumLevels</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Next file to compact based on seek stats.
</span></span></span><span class=line><span class=cl>  <span class=n>FileMetaData</span><span class=o>*</span> <span class=n>file_to_compact_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>file_to_compact_level_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Level that should be compacted next and its compaction score.
</span></span></span><span class=line><span class=cl>  <span class=c1>// Score &lt; 1 means compaction is not strictly needed.  These fields
</span></span></span><span class=line><span class=cl>  <span class=c1>// are initialized by Finalize().
</span></span></span><span class=line><span class=cl>  <span class=kt>double</span> <span class=n>compaction_score_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>compaction_level_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=class-versionset><a href=#class-versionset class=header-anchor></a>class versionset</h4><p>versionset主要用于管理多个version对象，负责维护数据库的版本历史和状态。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>VersionSet</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>Builder</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>friend</span> <span class=k>class</span> <span class=nc>Compaction</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>friend</span> <span class=k>class</span> <span class=nc>Version</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=nf>ReuseManifest</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>dscname</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>dscbase</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>Finalize</span><span class=p>(</span><span class=n>Version</span><span class=o>*</span> <span class=n>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 进行压缩或者查询时，了解数据范围有助于优化性能
</span></span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>GetRange</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>FileMetaData</span><span class=o>*&gt;&amp;</span> <span class=n>inputs</span><span class=p>,</span> <span class=n>InternalKey</span><span class=o>*</span> <span class=n>smallest</span><span class=p>,</span> <span class=n>InternalKey</span><span class=o>*</span> <span class=n>largest</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 合并文件时考虑文件范围
</span></span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>GetRange2</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>FileMetaData</span><span class=o>*&gt;&amp;</span> <span class=n>inputs1</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>FileMetaData</span><span class=o>*&gt;&amp;</span> <span class=n>inputs2</span><span class=p>,</span> <span class=n>InternalKey</span><span class=o>*</span> <span class=n>smallest</span><span class=p>,</span> <span class=n>InternalKey</span><span class=o>*</span> <span class=n>largest</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 为压缩操作设置其它输入文件
</span></span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>SetupOtherInputs</span><span class=p>(</span><span class=n>Compaction</span><span class=o>*</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Save current contents to *log
</span></span></span><span class=line><span class=cl>  <span class=n>Status</span> <span class=nf>WriteSnapshot</span><span class=p>(</span><span class=n>log</span><span class=o>::</span><span class=n>Writer</span><span class=o>*</span> <span class=n>log</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>AppendVersion</span><span class=p>(</span><span class=n>Version</span><span class=o>*</span> <span class=n>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>Env</span><span class=o>*</span> <span class=k>const</span> <span class=n>env_</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>dbname_</span><span class=p>;</span> <span class=c1>// 数据库名称
</span></span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>Options</span><span class=o>*</span> <span class=k>const</span> <span class=n>options_</span><span class=p>;</span> <span class=c1>// 数据库选项
</span></span></span><span class=line><span class=cl>  <span class=n>TableCache</span><span class=o>*</span> <span class=k>const</span> <span class=n>table_cache_</span><span class=p>;</span> <span class=c1>// 表缓存
</span></span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>InternalKeyComparator</span> <span class=n>icmp_</span><span class=p>;</span> <span class=c1>// 内部键比较器
</span></span></span><span class=line><span class=cl>  <span class=kt>uint64_t</span> <span class=n>next_file_number_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint64_t</span> <span class=n>manifest_file_number_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint64_t</span> <span class=n>last_sequence_</span><span class=p>;</span> <span class=c1>// 所有写操作中最后使用的序列号
</span></span></span><span class=line><span class=cl>  <span class=kt>uint64_t</span> <span class=n>log_number_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint64_t</span> <span class=n>prev_log_number_</span><span class=p>;</span>  <span class=c1>// 0 or backing store for memtable being compacted
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Opened lazily
</span></span></span><span class=line><span class=cl>  <span class=n>WritableFile</span><span class=o>*</span> <span class=n>descriptor_file_</span><span class=p>;</span>  <span class=c1>// 数据库描述符文件
</span></span></span><span class=line><span class=cl>  <span class=n>log</span><span class=o>::</span><span class=n>Writer</span><span class=o>*</span> <span class=n>descriptor_log_</span><span class=p>;</span> <span class=c1>// 写入日志
</span></span></span><span class=line><span class=cl>  <span class=n>Version</span> <span class=n>dummy_versions_</span><span class=p>;</span>  <span class=c1>// Head of circular doubly-linked list of versions.循环双链表的虚拟头
</span></span></span><span class=line><span class=cl>  <span class=n>Version</span><span class=o>*</span> <span class=n>current_</span><span class=p>;</span>        <span class=c1>// == dummy_versions_.prev_指向当前版本
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Per-level key at which the next compaction at that level should start.压缩指针
</span></span></span><span class=line><span class=cl>  <span class=c1>// Either an empty string, or a valid InternalKey.
</span></span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>compact_pointer_</span><span class=p>[</span><span class=n>config</span><span class=o>::</span><span class=n>kNumLevels</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>通过<code>LogAndApply()</code>方法应用<code>VersionEdit</code>对象，创建新的<code>Version</code>并将其添加到<code>VersionSet</code>中。下面来看看LogAndApply函数的过程：</p><ol><li><p><strong>保存状态</strong>：首先，它会保存当前的锁状态，以确保在写入文件时不会有其他线程干扰。</p></li><li><p><strong>更新版本</strong>：接着，通过传入的<code>VersionEdit</code>对象，更新当前的版本信息。这可能包括创建新版本，保存新版本到builder类中，删除旧文件、更新日志编号等。</p></li><li><p><strong>写入日志</strong>：在更新版本的同时，<code>LogAndApply</code>会将这些变更记录到持久化日志中，以便后续的恢复操作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>  <span class=n>Status</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>descriptor_log_</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// No reason to unlock *mu here since we only hit this path in the
</span></span></span><span class=line><span class=cl>    <span class=c1>// first call to LogAndApply (when opening the database).
</span></span></span><span class=line><span class=cl>    <span class=n>assert</span><span class=p>(</span><span class=n>descriptor_file_</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 日志为空时，生成新的描述符文件名，创建可写文件
</span></span></span><span class=line><span class=cl>    <span class=n>new_manifest_file</span> <span class=o>=</span> <span class=n>DescriptorFileName</span><span class=p>(</span><span class=n>dbname_</span><span class=p>,</span> <span class=n>manifest_file_number_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>=</span> <span class=n>env_</span><span class=o>-&gt;</span><span class=n>NewWritableFile</span><span class=p>(</span><span class=n>new_manifest_file</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>descriptor_file_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 将其作为新的日志写入其，同时将当前版本快照写入日志
</span></span></span><span class=line><span class=cl>      <span class=n>descriptor_log_</span> <span class=o>=</span> <span class=k>new</span> <span class=n>log</span><span class=o>::</span><span class=n>Writer</span><span class=p>(</span><span class=n>descriptor_file_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>s</span> <span class=o>=</span> <span class=n>WriteSnapshot</span><span class=p>(</span><span class=n>descriptor_log_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>应用更改</strong>：更新完成后，函数会应用这些更改到当前版本，确保数据库状态与日志一致。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>mu</span><span class=o>-&gt;</span><span class=n>Unlock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Write new record to MANIFEST log
</span></span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>record</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>edit</span><span class=o>-&gt;</span><span class=n>EncodeTo</span><span class=p>(</span><span class=o>&amp;</span><span class=n>record</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>s</span> <span class=o>=</span> <span class=n>descriptor_log_</span><span class=o>-&gt;</span><span class=n>AddRecord</span><span class=p>(</span><span class=n>record</span><span class=p>);</span> <span class=c1>//使用 descriptor_log_ 将该记录添加到MANIFEST日志中。
</span></span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span> <span class=c1>// 同步到磁盘，确保写入持久化
</span></span></span><span class=line><span class=cl>        <span class=n>s</span> <span class=o>=</span> <span class=n>descriptor_file_</span><span class=o>-&gt;</span><span class=n>Sync</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>s</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Log</span><span class=p>(</span><span class=n>options_</span><span class=o>-&gt;</span><span class=n>info_log</span><span class=p>,</span> <span class=s>&#34;MANIFEST write: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>s</span><span class=p>.</span><span class=n>ToString</span><span class=p>().</span><span class=n>c_str</span><span class=p>());</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// If we just created a new descriptor file, install it by writing a
</span></span></span><span class=line><span class=cl>    <span class=c1>// new CURRENT file that points to it.
</span></span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>ok</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>new_manifest_file</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 更新current文件，指向新创建的描述符文件
</span></span></span><span class=line><span class=cl>      <span class=n>s</span> <span class=o>=</span> <span class=n>SetCurrentFile</span><span class=p>(</span><span class=n>env_</span><span class=p>,</span> <span class=n>dbname_</span><span class=p>,</span> <span class=n>manifest_file_number_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>mu</span><span class=o>-&gt;</span><span class=n>Lock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>释放锁</strong>：最后，释放锁并返回结果，完成整个过程。</p></li></ol><h3 id=recover><a href=#recover class=header-anchor></a>Recover</h3><p>由于数据库启动前需要恢复数据，也就是利用Manifest信息重新构建一个最新的version。</p><ol><li><p>利用current文件读取最近使用的Manifest文件。</p></li><li><p>创建一个空的version，利用manifest文件中的session record依次apply，还原出一个最新的version，注意manifest的第一条session record记录的是一个version的snapshot，后面记录的都是增量。</p><p>（为了避免manifest过大，每次启动时重新创建的manifest的第一条都是当前版本的快照状态，其它过期的manifest文件会在下次启动的recover流程中自行删除）</p></li><li><p>将非current文件指向的其它过期的manifest文件删除。</p></li><li><p>将新建的version作为当前数据库的version。</p></li></ol><p><img src=/img/images/23.jpg loading=lazy alt=23></p><h3 id=repair><a href=#repair class=header-anchor></a>Repair</h3><p>repair.cc中只有一个公共接口，Run()</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>  <span class=n>Status</span> <span class=nf>Run</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*查找数据库目录中的文件
</span></span></span><span class=line><span class=cl><span class=cm>    * 解析文件名，提取文件编号和类型
</span></span></span><span class=line><span class=cl><span class=cm>    * 对于描述符文件，文件名存入manifest
</span></span></span><span class=line><span class=cl><span class=cm>    * 对于日志和表文件，存储在logs和table_number中
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=n>Status</span> <span class=n>status</span> <span class=o>=</span> <span class=n>FindFiles</span><span class=p>();</span> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>ConvertLogFilesToTables</span><span class=p>();</span> <span class=c1>// 将日志文件转换成表文件
</span></span></span><span class=line><span class=cl>      <span class=n>ExtractMetaData</span><span class=p>();</span> <span class=c1>// 获取每个文件的元数据(key)以及最终数据库的元数据(seq)
</span></span></span><span class=line><span class=cl>      <span class=n>status</span> <span class=o>=</span> <span class=n>WriteDescriptor</span><span class=p>();</span> <span class=c1>// 创建一个新的manifest文件，将扫描的数据库元数据进行记录
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>bytes</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>tables_</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>bytes</span> <span class=o>+=</span> <span class=n>tables_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>meta</span><span class=p>.</span><span class=n>file_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=n>Log</span><span class=p>(</span><span class=n>options_</span><span class=p>.</span><span class=n>info_log</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=s>&#34;**** Repaired leveldb %s; &#34;</span>
</span></span><span class=line><span class=cl>          <span class=s>&#34;recovered %d files; %llu bytes. &#34;</span>
</span></span><span class=line><span class=cl>          <span class=s>&#34;Some data may have been lost. &#34;</span>
</span></span><span class=line><span class=cl>          <span class=s>&#34;****&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=n>dbname_</span><span class=p>.</span><span class=n>c_str</span><span class=p>(),</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>tables_</span><span class=p>.</span><span class=n>size</span><span class=p>()),</span> <span class=n>bytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>但是该方法的效率十分低下，首先需要对整个数据库的文件进行扫描，其次0层的文件必然将远远大于4个，这将导致极多的compaction发生。</p><p>有关这部分的大致内容就是这样子了，关于version的内容其实可以再次精细化，留个点位，leveldb整体一遍学完后也还会留时间再回头看看的。</p></section><footer class=article-footer><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/p/%E8%AF%A6%E8%B0%88leveldb%E4%B8%AD%E7%9A%84sstable/><div class=article-image><img src=/images/dfcceaca.jpg loading=lazy data-key data-hash=/images/dfcceaca.jpg></div><div class=article-details><h2 class=article-title>详谈leveldb中的sstable</h2></div></a></article><article class=has-image><a href=/p/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB8-orient%E9%9D%A2%E8%AF%95/><div class=article-image><img src=/images/fee4263f.jpg loading=lazy data-key data-hash=/images/fee4263f.jpg></div><div class=article-details><h2 class=article-title>leveldb源码阅读8 Orient面试</h2></div></a></article><article class=has-image><a href=/p/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB7-question/><div class=article-image><img src=/images/9b9f137c.jpg loading=lazy data-key data-hash=/images/9b9f137c.jpg></div><div class=article-details><h2 class=article-title>leveldb源码阅读7 Question</h2></div></a></article><article class=has-image><a href=/p/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB6-wirteread-and-log/><div class=article-image><img src=/images/9ca73f67.jpg loading=lazy data-key data-hash=/images/9ca73f67.jpg></div><div class=article-details><h2 class=article-title>leveldb源码阅读6 wirte&amp;read and log</h2></div></a></article><article class=has-image><a href=/p/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB4-snapshotbloom-filter/><div class=article-image><img src=/images/505bc7b2.jpg loading=lazy data-key data-hash=/images/505bc7b2.jpg></div><div class=article-details><h2 class=article-title>leveldb源码阅读4 snapshot,Bloom Filter</h2></div></a></article></div></div></aside><script src=//unpkg.com/@waline/client@v2/dist/waline.js></script><link href=//unpkg.com/@waline/client@v2/dist/waline.css rel=stylesheet><div id=waline class=waline-container></div><style>.waline-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding);--waline-font-size:var(--article-font-size)}.waline-container .wl-count{color:var(--card-text-color-main)}</style><script>Waline.init({avatar:"wavatar",dark:'html[data-scheme="dark"]',el:"#waline",emoji:["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],lang:"zh-cn",locale:{admin:"Admin",placeholder:null},placeholder:"说点什么吧...",requiredMeta:["name","email","url"],serverURL:"https://repo-r1tkfif8s-jias-projects-9d2d822c.vercel.app/",visitor:"true"})</script><footer class=site-footer><section class=copyright>&copy;
2023 -
2026 Sutdown</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.33.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.c922af694cc257bf1ecc41c0dd7b0430f9114ec280ccf67cd2c6ad55f5316c4e.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>